Estrutura de pastas e arquivos com conte√∫do:
--- Caminho: backend ---
--- Caminho: backend/Dockerfile ---
```dockerfile
FROM node:20-alpine AS base

WORKDIR /app

COPY package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./

RUN \
    if [ -f yarn.lock ]; then yarn install --frozen-lockfile; \
    elif [ -f package-lock.json ]; then npm ci; \
    elif [ -f pnpm-lock.yaml ]; then pnpm i --frozen-lockfile; \
    else npm ci; \
    fi

FROM base AS builder

WORKDIR /app

COPY --from=base /app/node_modules ./node_modules
COPY tsconfig.json .
COPY src ./src

RUN npx tsc

FROM node:20-alpine AS runner

WORKDIR /app

# Instalar dockerize para aguardar o PostgreSQL
RUN apk add --no-cache wget
RUN wget https://github.com/jwilder/dockerize/releases/download/v0.6.1/dockerize-alpine-linux-amd64-v0.6.1.tar.gz \
    && tar -C /usr/local/bin -xzvf dockerize-alpine-linux-amd64-v0.6.1.tar.gz \
    && rm dockerize-alpine-linux-amd64-v0.6.1.tar.gz

COPY --from=builder /app/dist ./dist
COPY --from=base /app/node_modules ./node_modules
COPY package.json .

# Comando padr√£o aguarda o banco e inicia a aplica√ß√£o
CMD ["dockerize", "-wait", "tcp://logo-ali-db:5432", "-timeout", "30s", "node", "./dist/index.js"]
```

--- Caminho: backend/package.json ---
```json
{
  "name": "backend",
  "version": "1.0.0",
  "description": "API Backend para LogoAli - Servi√ßos P√∫blicos SP",
  "main": "dist/index.js",
  "scripts": {
    "build": "npx tsc",
    "start": "node ./dist/index.js",
    "dev": "ts-node src/index.ts",
    "dev:watch": "nodemon --exec ts-node src/index.ts",
    "migrate:up": "npx ts-node src/database/migrations/migrate.ts up",
    "docker:reset": "docker-compose -f ../infra/docker-compose.yml down -v && docker system prune -a --volumes -f && docker-compose -f ../infra/docker-compose.yml build --no-cache && docker-compose -f ../infra/docker-compose.yml up -d && npm run migrate:up && npm run dev"
  },
  "keywords": [
    "viacep",
    "api",
    "cache",
    "sao-paulo",
    "servicos-publicos"
  ],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "axios": "^1.7.2",
    "cheerio": "^1.0.0-rc.12",
    "dotenv": "^17.2.1",
    "express": "^5.1.0",
    "pg": "^8.16.3"
  },
  "devDependencies": {
    "@types/express": "^5.0.3",
    "@types/node": "^24.1.0",
    "@types/pg": "^8.15.5",
    "nodemon": "^3.1.10",
    "ts-node": "^10.9.2",
    "typescript": "^5.8.3"
  }
}

```

--- Caminho: backend/src ---
--- Caminho: backend/src/controllers ---
--- Caminho: backend/src/controllers/cataBagulhoController.ts ---
```typescript
import { Request, Response } from "express";
import { CataBagulhoService } from "../services/cataBagulhoService";

export class CataBagulhoController {
  private cataBagulhoService: CataBagulhoService;

  constructor() {
    this.cataBagulhoService = new CataBagulhoService();
  }

  public search = async (req: Request, res: Response): Promise<void> => {
    const { lat, lng } = req.query;

    if (!lat || !lng) {
      res.status(400).json({ error: "Latitude (lat) e Longitude (lng) s√£o obrigat√≥rias." });
      return;
    }

    try {
      const latitude = parseFloat(lat as string);
      const longitude = parseFloat(lng as string);
      const results = await this.cataBagulhoService.search(latitude, longitude);
      res.status(200).json({ data: results });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  };
}
```

--- Caminho: backend/src/controllers/geocodeController.ts ---
```typescript
// --- Caminho: backend/src/controllers/geocodeController.ts ---
import { Request, Response } from "express";
import { GeocodeService } from "../services/geocodeService";

export class GeocodeController {
  private geocodeService = new GeocodeService();

  public search = async (req: Request, res: Response): Promise<void> => {
    const { q } = req.query;

    if (!q || typeof q !== "string") {
      res.status(400).json({ success: false, message: "Par√¢metro de busca 'q' √© obrigat√≥rio." });
      return;
    }

    try {
      const results = await this.geocodeService.getCoordinatesFromAddress(q);
      res.status(200).json({ success: true, data: results });
    } catch (error: any) {
      res.status(500).json({ success: false, message: error.message || "Erro interno ao buscar coordenadas." });
    }
  };
}
```

--- Caminho: backend/src/controllers/viacepController.ts ---
```typescript
import { Request, Response } from "express";
import { ViaCepService } from "../services/viacepService";
import { ViaCepResponse } from "../types/viacep";

export class ViaCepController {
  private viaCepService = new ViaCepService();

  public getCep = async (req: Request, res: Response) => {
    try {
      const { cep } = req.params;
      if (!cep) {
        return res.status(400).json({ success: false, message: "CEP √© obrigat√≥rio" });
      }
      const data = await this.viaCepService.buscarEnderecoPorCep(cep);
      return res.status(200).json({ success: true, data });
    } catch (error: any) {
      console.error("[ViaCepController:getCep] Erro:", error?.message || error);
      return res.status(500).json({ success: false, message: "Erro ao buscar CEP" });
    }
  };

  public getCacheStats = (_req: Request, res: Response) => {
    const stats = this.viaCepService.getCacheStats();
    return res.status(200).json({ success: true, data: stats });
  };

  public clearExpiredCache = (_req: Request, res: Response) => {
    const result = this.viaCepService.clearExpiredCache();
    return res.status(200).json({ success: true, data: result });
  };

  /**
   * Endpoint de teste para popular o cache com dados fake.
   * POST /api/cep/test/fake
   * body: { cep: "01001000", data?: ViaCepResponse }
   */
  public testWithFakeData = (req: Request, res: Response) => {
    try {
      const { cep, data } = req.body as { cep?: string; data?: ViaCepResponse };
      if (!cep) {
        return res.status(400).json({ success: false, message: "Informe um CEP no corpo da requisi√ß√£o." });
      }

      // Dados padr√£o se n√£o enviar "data"
      const fake: ViaCepResponse =
        data || {
          cep: "01001-000",
          logradouro: "Pra√ßa da S√©",
          complemento: "lado √≠mpar",
          unidade: "",
          bairro: "S√©",
          localidade: "S√£o Paulo",
          uf: "SP",
        };

      const r = this.viaCepService.seedCache(cep, fake);
      return res.status(200).json({ success: true, data: { ...r, fake } });
    } catch (error: any) {
      console.error("[ViaCepController:testWithFakeData] Erro:", error?.message || error);
      return res.status(500).json({ success: false, message: "Erro ao inserir dados fake no cache" });
    }
  };
}

```


--- Caminho: backend/src/database ---
--- Caminho: backend/src/database/database.ts ---
```typescript
import { Pool, QueryResult, QueryResultRow } from "pg";
import dotenv from "dotenv";
import path from "path";

// Carregar vari√°veis de ambiente
dotenv.config({
  path: path.resolve(__dirname, "..", "..", "..", ".env.development"),
});

// Determina a porta baseada no ambiente
function getDatabasePort(): number {
  const envPort = process.env.POSTGRES_PORT;

  // Se estamos dentro do Docker (NODE_ENV=development com Docker)
  // o PostgreSQL sempre roda na porta 5432 DENTRO da rede Docker
  if (
    process.env.NODE_ENV === "development" &&
    process.env.POSTGRES_HOST === "logo-ali-db"
  ) {
    console.log("üê≥ Executando dentro do Docker - usando porta interna 5432");
    return 5432;
  }

  // Se estamos rodando localmente (fora do Docker)
  // usa a porta do .env (5434 para este projeto)
  console.log(`üíª Executando localmente - usando porta ${envPort}`);
  return Number(envPort) || 5432;
}

const pool = new Pool({
  host: process.env.POSTGRES_HOST,
  port: getDatabasePort(),
  user: process.env.POSTGRES_USER,
  database: process.env.POSTGRES_DB,
  password: process.env.POSTGRES_PASSWORD,
  ssl: process.env.NODE_ENV === "production" ? true : false,
});

async function query(
  queryObject: string,
  params: any[] = []
): Promise<QueryResult<QueryResultRow>> {
  try {
    const result = await pool.query(queryObject, params);
    return result;
  } catch (error) {
    console.error(error);
    throw error;
  }
}

async function getClient() {
  return pool.connect();
}

export default {
  query,
  getClient,
};

```

--- Caminho: backend/src/database/migrations ---
--- Caminho: backend/src/database/migrations/001_initial_setup.sql ---
```sql
-- Migra√ß√£o inicial do sistema LogoAli
-- Arquivo: C:\workspace\Meus Projetos\LogoAli\logo-ali\backend\src\database\migrations\001_initial_setup.sql

-- Cria√ß√£o de extens√µes √∫teis (se necess√°rio)
-- CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Configura√ß√µes iniciais do banco
-- COMMENT ON DATABASE logo_ali_db IS 'Banco de dados do sistema LogoAli - Servi√ßos P√∫blicos SP';

-- Log da migra√ß√£o inicial
DO $$ 
BEGIN
    RAISE NOTICE 'Executando migra√ß√£o inicial 001_initial_setup.sql';
    RAISE NOTICE 'Sistema LogoAli - Base de dados inicializada';
END $$;
```

--- Caminho: backend/src/database/migrations/002_create_viacep_cache.sql ---
```sql
-- Migra√ß√£o para criar tabela de cache do ViaCEP
-- Arquivo: C:\workspace\Meus Projetos\LogoAli\logo-ali\backend\src\database\migrations\002_create_viacep_cache.sql

CREATE TABLE IF NOT EXISTS viacep_cache (
  id SERIAL PRIMARY KEY,
  cep VARCHAR(9) NOT NULL UNIQUE, -- formato: 01001-000
  logradouro VARCHAR(255),
  complemento VARCHAR(255),
  unidade VARCHAR(50),
  bairro VARCHAR(100),
  localidade VARCHAR(100),
  uf VARCHAR(2),
  cached_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- √çndices para otimizar consultas
CREATE INDEX IF NOT EXISTS idx_viacep_cache_cep ON viacep_cache(cep);
CREATE INDEX IF NOT EXISTS idx_viacep_cache_expires ON viacep_cache(expires_at);

-- Coment√°rios para documenta√ß√£o
COMMENT ON TABLE viacep_cache IS 'Cache para dados do ViaCEP com TTL de 24 horas';
COMMENT ON COLUMN viacep_cache.cep IS 'CEP no formato 00000-000';
COMMENT ON COLUMN viacep_cache.expires_at IS 'Data/hora de expira√ß√£o do cache';
COMMENT ON COLUMN viacep_cache.cached_at IS 'Quando foi armazenado no cache';
```

--- Caminho: backend/src/database/migrations/003_create_catabagulho_cache.sql ---
```sql
-- Migra√ß√£o para criar a tabela de cache do servi√ßo Cata-Bagulho
-- Arquivo: backend/src/database/migrations/003_create_catabagulho_cache.sql

CREATE TABLE IF NOT EXISTS catabagulho_cache (
  id SERIAL PRIMARY KEY,
  latitude DECIMAL(10, 8) NOT NULL,
  longitude DECIMAL(11, 8) NOT NULL,
  results JSONB NOT NULL,
  cached_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL
);

-- √çndice para otimizar a busca por coordenadas e data de expira√ß√£o
CREATE INDEX IF NOT EXISTS idx_catabagulho_cache_coords ON catabagulho_cache(latitude, longitude);
CREATE INDEX IF NOT EXISTS idx_catabagulho_cache_expires ON catabagulho_cache(expires_at);

-- Adiciona um √≠ndice √∫nico para evitar duplicatas exatas de coordenadas
-- Isso garante que para um par (lat, lng) s√≥ haver√° um registro de cache por vez
ALTER TABLE catabagulho_cache
ADD CONSTRAINT unique_coords_catabagulho UNIQUE (latitude, longitude);


COMMENT ON TABLE catabagulho_cache IS 'Cache para os resultados do web scraping do servi√ßo Cata-Bagulho, com TTL de 24 horas.';
COMMENT ON COLUMN catabagulho_cache.latitude IS 'Latitude da busca original.';
COMMENT ON COLUMN catabagulho_cache.longitude IS 'Longitude da busca original.';
COMMENT ON COLUMN catabagulho_cache.results IS 'Resultados da busca em formato JSON.';
COMMENT ON COLUMN catabagulho_cache.expires_at IS 'Data e hora de expira√ß√£o do registro de cache.';
```

--- Caminho: backend/src/database/migrations/migrate.ts ---
```typescript
import fs from "fs";
import path from "path";
import db from "../database";

interface Migration {
  id: number;
  filename: string;
  content: string;
}

async function createMigrationsTable() {
  const query = `
    CREATE TABLE IF NOT EXISTS migrations (
      id SERIAL PRIMARY KEY,
      filename VARCHAR(255) NOT NULL UNIQUE,
      executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
  `;

  try {
    console.log("üîÑ Criando tabela de migra√ß√µes...");
    await db.query(query);
    console.log("‚úÖ Tabela 'migrations' criada/verificada com sucesso");
  } catch (error) {
    console.error("‚ùå Erro ao criar tabela de migra√ß√µes:", error);
    throw error;
  }
}

async function getExecutedMigrations(): Promise<string[]> {
  try {
    const result = await db.query(
      "SELECT filename FROM migrations ORDER BY id",
    );
    return result.rows.map((row: any) => row.filename);
  } catch (error) {
    // Se a tabela n√£o existir ainda
    if ((error as any).code === "42P01") {
      console.log("üìã Tabela de migra√ß√µes ainda n√£o existe");
      return [];
    }
    console.error("‚ùå Erro ao obter migra√ß√µes executadas:", error);
    throw error;
  }
}

async function getMigrationFiles(): Promise<Migration[]> {
  const migrationsDir = __dirname;

  if (!fs.existsSync(migrationsDir)) {
    console.log("üìÅ Criando diret√≥rio de migra√ß√µes...");
    fs.mkdirSync(migrationsDir, { recursive: true });
    return [];
  }

  const files = fs
    .readdirSync(migrationsDir)
    .filter((file) => file.endsWith(".sql"))
    .sort();

  console.log(`üìÑ Encontrados ${files.length} arquivos de migra√ß√£o:`, files);

  return files.map((filename) => {
    const content = fs.readFileSync(path.join(migrationsDir, filename), "utf8");
    const id = parseInt(filename.split("_")[0]) || 0;
    return { id, filename, content };
  });
}

async function executeMigration(migration: Migration) {
  const client = await db.getClient();

  try {
    console.log(`üîÑ Executando migra√ß√£o: ${migration.filename}`);

    // Inicia transa√ß√£o
    await client.query("BEGIN");

    // Executa o SQL da migra√ß√£o
    if (migration.content.trim()) {
      console.log(`üìù Executando SQL da migra√ß√£o...`);
      await client.query(migration.content);
    }

    // Registra a migra√ß√£o como executada
    await client.query("INSERT INTO migrations (filename) VALUES ($1)", [
      migration.filename,
    ]);

    // Confirma transa√ß√£o
    await client.query("COMMIT");

    console.log(`‚úÖ Migra√ß√£o executada com sucesso: ${migration.filename}`);
  } catch (error) {
    // Desfaz transa√ß√£o em caso de erro
    await client.query("ROLLBACK");
    console.error(`‚ùå Erro na migra√ß√£o ${migration.filename}:`, error);
    throw error;
  } finally {
    client.release();
  }
}

export async function runMigrations() {
  try {
    console.log("üöÄ Iniciando sistema de migra√ß√µes...");

    // Primeiro cria a tabela de migra√ß√µes
    await createMigrationsTable();

    // Busca migra√ß√µes j√° executadas
    const executedMigrations = await getExecutedMigrations();
    console.log(`üìã Migra√ß√µes j√° executadas: ${executedMigrations.length}`);

    // Busca arquivos de migra√ß√£o
    const migrationFiles = await getMigrationFiles();

    // Filtra migra√ß√µes pendentes
    const pendingMigrations = migrationFiles.filter(
      (migration) => !executedMigrations.includes(migration.filename),
    );

    if (pendingMigrations.length === 0) {
      console.log("‚úÖ Nenhuma migra√ß√£o pendente encontrada");
      return;
    }

    console.log(
      `‚öôÔ∏è Executando ${pendingMigrations.length} migra√ß√µes pendentes...`,
    );

    for (const migration of pendingMigrations) {
      await executeMigration(migration);
    }

    console.log("üéâ Todas as migra√ß√µes foram executadas com sucesso!");
  } catch (error) {
    console.error("üí• Erro durante execu√ß√£o das migra√ß√µes:", error);
    throw error;
  }
}

```



--- Caminho: backend/src/index.ts ---
```typescript
// --- Caminho: backend/src/index.ts ---
import express from "express";
import dotenv from "dotenv";
import path from "path";
import db from "./database/database";
import { runMigrations } from "./database/migrations/migrate";
import viaCepRoutes from "./routes/viacepRoutes";
import cataBagulhoRoutes from "./routes/cataBagulhoRoutes";
import geocodeRoutes from "./routes/geocodeRoutes"; // <-- IMPORTAR NOVA ROTA

// Carrega vari√°veis de ambiente
dotenv.config({
  path: path.resolve(__dirname, "..", "..", ".env.development"),
});

const app = express();
const PORT = process.env.BACKEND_PORT || 3333;

app.use(express.json());

async function startServer() {
  try {
    console.log("üîß === DEBUG INFO ===");
    console.log("NODE_ENV:", process.env.NODE_ENV);
    console.log("POSTGRES_HOST:", process.env.POSTGRES_HOST);
    // ... (restante dos console.log de debug)
    console.log("===================");

    console.log("üîÑ Aguardando 5 segundos para o PostgreSQL inicializar...");
    await new Promise((resolve) => setTimeout(resolve, 5000));

    // ... (restante da l√≥gica de teste de conex√£o e migra√ß√£o)
    console.log("üîÑ Testando conex√£o com banco de dados...");
    const testResult = await db.query("SELECT NOW() as current_time");
    console.log("‚úÖ Conex√£o com banco estabelecida!", testResult.rows[0].current_time);

    console.log("üîÑ Iniciando migra√ß√µes...");
    await runMigrations();
    console.log("‚úÖ Migra√ß√µes conclu√≠das!");

    // ========== ROTAS ==========

    // Rota de status do sistema
    app.get("/api/status", async (req, res) => {
        // ... (c√≥digo da rota de status)
        try {
            const dbTest = await db.query("SELECT NOW() as time");
            res.status(200).json({ status: "Backend is running!", database: "Connected", server_time: dbTest.rows[0].time });
        } catch (error: any) {
            res.status(500).json({ status: "Backend is running!", database: "Disconnected", error: error.message });
        }
    });
    
    // Registrar rotas
    app.use("/api", viaCepRoutes);
    app.use("/api", cataBagulhoRoutes);
    app.use("/api", geocodeRoutes); // <-- REGISTRAR NOVA ROTA

    // Middleware para rotas n√£o encontradas
    app.use((req, res) => {
      res.status(404).json({
        error: "Rota n√£o encontrada",
        message: `Endpoint ${req.method} ${req.originalUrl} n√£o existe`,
      });
    });

    app.listen(PORT, () => {
      console.log(`üöÄ Backend server listening on port ${PORT}`);
      console.log(`üìä Status: http://localhost:${PORT}/api/status`);
      console.log(`üìç ViaCEP: http://localhost:${PORT}/api/cep/{cep}`);
      console.log(`üåç Geocode: http://localhost:${PORT}/api/geocode?q={endereco}`);
    });
  } catch (error) {
    console.error("üí• FALHA CR√çTICA ao iniciar o backend:", error);
    process.exit(1);
  }
}

startServer();
```

--- Caminho: backend/src/routes ---
--- Caminho: backend/src/routes/cataBagulhoRoutes.ts ---
```typescript
import { Router } from "express";
import { CataBagulhoController } from "../controllers/cataBagulhoController";

const router = Router();
const controller = new CataBagulhoController();

router.get("/cata-bagulho", controller.search);

export default router;
```

--- Caminho: backend/src/routes/geocodeRoutes.ts ---
```typescript
// --- Caminho: backend/src/routes/geocodeRoutes.ts ---
import { Router } from "express";
import { GeocodeController } from "../controllers/geocodeController";

const router = Router();
const controller = new GeocodeController();

// Rota para geocodifica√ß√£o, ex: /api/geocode?q=Avenida Paulista, 1500
router.get("/geocode", controller.search);

export default router;
```

--- Caminho: backend/src/routes/viacepRoutes.ts ---
```typescript
import { Router } from "express";
import { ViaCepController } from "../controllers/viacepController";

const router = Router();
const viaCepController = new ViaCepController();

router.post("/cep/test/fake", viaCepController.testWithFakeData);
router.get("/cep/cache/stats", viaCepController.getCacheStats);
router.delete("/cep/cache/expired", viaCepController.clearExpiredCache);
router.get("/cep/:cep", viaCepController.getCep);

export default router;

```


--- Caminho: backend/src/services ---
--- Caminho: backend/src/services/cataBagulhoService.ts ---
```typescript
// --- Caminho: backend/src/services/cataBagulhoService.ts ---
import axios from "axios";
import * as cheerio from "cheerio";
import db from "../database/database";
import { CataBagulhoResult } from "../types/cataBagulho";

export class CataBagulhoService {
  private readonly BASE_URL = "https://locatsp.saclimpeza2.com.br/mapa/resultados/";
  private readonly CACHE_TTL_HOURS = 24;

  public async search(lat: number, lng: number): Promise<CataBagulhoResult[]> {
    const cachedResults = await this.getCachedResults(lat, lng);
    if (cachedResults) {
      console.log(`‚úÖ [Cata-Bagulho] Cache HIT para coordenadas: ${lat}, ${lng}`);
      return cachedResults;
    }

    console.log(`‚ùå [Cata-Bagulho] Cache MISS. Buscando na fonte externa...`);
    const liveResults = await this.fetchFromSource(lat, lng);

    if (liveResults.length > 0) {
      await this.cacheResults(lat, lng, liveResults);
    }

    return liveResults;
  }

  private async getCachedResults(lat: number, lng: number): Promise<CataBagulhoResult[] | null> {
    try {
      const query = `
        SELECT results FROM catabagulho_cache
        WHERE latitude = $1 AND longitude = $2 AND expires_at > NOW()
        LIMIT 1;
      `;
      const result = await db.query(query, [lat.toFixed(8), lng.toFixed(8)]);
      if (result.rows.length > 0) {
        return result.rows[0].results as CataBagulhoResult[];
      }
      return null;
    } catch (error) {
      console.error("Erro ao buscar resultados do cache Cata-Bagulho:", error);
      return null;
    }
  }

  private async cacheResults(lat: number, lng: number, results: CataBagulhoResult[]): Promise<void> {
    try {
      const expiresAt = new Date();
      expiresAt.setHours(expiresAt.getHours() + this.CACHE_TTL_HOURS);

      const query = `
        INSERT INTO catabagulho_cache (latitude, longitude, results, expires_at)
        VALUES ($1, $2, $3, $4)
        ON CONFLICT (latitude, longitude)
        DO UPDATE SET
          results = EXCLUDED.results,
          cached_at = CURRENT_TIMESTAMP,
          expires_at = EXCLUDED.expires_at;
      `;

      await db.query(query, [lat.toFixed(8), lng.toFixed(8), JSON.stringify(results), expiresAt]);
      console.log(`üíæ [Cata-Bagulho] Resultados para ${lat}, ${lng} salvos no cache.`);
    } catch (error) {
      console.error("Erro ao salvar resultados no cache Cata-Bagulho:", error);
    }
  }

  private async fetchFromSource(lat: number, lng: number): Promise<CataBagulhoResult[]> {
    const url = `${this.BASE_URL}?servico=grandes-objetos&lat=${lat}&lng=${lng}`;
    console.log(`[Cata-Bagulho] Buscando dados em: ${url}`);

    try {
      const { data } = await axios.get(url, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        },
        timeout: 15000,
      });
      return this.parseHTML(data);
    } catch (error: any) {
      console.error("[Cata-Bagulho] Erro no servi√ßo de scraping:", error.message);
      throw new Error("N√£o foi poss√≠vel obter os dados do servi√ßo Cata-Bagulho.");
    }
  }

  private parseHTML(html: string): CataBagulhoResult[] {
    const $ = cheerio.load(html);
    const results: CataBagulhoResult[] = [];

    // O seletor correto para cada bloco de resultado
    $('.panel.panel-default').each((_, element) => {
      const logradouroDiv = $(element).find('.logradouro');
      const street = logradouroDiv.find('strong').text().trim();
      
      if (!street) return; // Pula se n√£o encontrar o nome da rua

      // Extrai o conte√∫do de texto do div e remove o nome da rua para pegar os trechos
      const logradouroHtml = logradouroDiv.html() || '';
      const parts = logradouroHtml.split('<br>').map(part => cheerio.load(part).text().trim());
      
      const startStretch = parts.find(p => p.startsWith('In√≠cio:'))?.replace('In√≠cio:', '').trim() || 'N√£o informado';
      const endStretch = parts.find(p => p.startsWith('Fim:'))?.replace('Fim:', '').trim() || 'N√£o informado';

      const detailsDiv = $(element).find('.detalhes');
      
      const extractDetail = (label: string): string => {
        return detailsDiv.find('.row').filter(function() {
          return $(this).find('.col-xs-3, .col-xs-4, .col-xs-5').text().trim() === label;
        }).find('.col-xs-9, .col-xs-8, .col-xs-7').text().trim() || 'N√£o informado';
      };

      const datesText = extractDetail('Dias:');
      const dates = datesText.split(';').map(d => d.trim()).filter(d => d);

      results.push({
        street: street,
        startStretch: startStretch,
        endStretch: endStretch,
        dates: dates,
        frequency: extractDetail('Freq.:'),
        shift: extractDetail('Turno:'),
        schedule: extractDetail('Hor√°rio:'),
      });
    });

    if (results.length === 0) {
        console.log("[Cata-Bagulho] Nenhum item de resultado encontrado no HTML com os seletores esperados.");
    }

    return results;
  }
}
```

--- Caminho: backend/src/services/geocodeService.ts ---
```typescript
// --- Caminho: backend/src/services/geocodeService.ts ---
import axios from "axios";

interface NominatimResult {
  place_id: number;
  lat: string;
  lon: string;
  display_name: string;
}

export class GeocodeService {
  private readonly NOMINATIM_URL = "https://nominatim.openstreetmap.org/search";

  public async getCoordinatesFromAddress(query: string): Promise<NominatimResult[]> {
    console.log(`[GeocodeService] Buscando coordenadas para: "${query}"`);
    try {
      const { data } = await axios.get<NominatimResult[]>(this.NOMINATIM_URL, {
        params: {
          q: query,
          format: "json",
          limit: 5, // Aumentar o limite pode ajudar a encontrar o endere√ßo correto
          addressdetails: 1,
          "accept-language": "pt-BR",
        },
        headers: {
          // √â uma boa pr√°tica definir um User-Agent
          "User-Agent": "LogoAli-App/1.0.0 (https://github.com/seu-usuario/seu-repo)",
        },
        timeout: 10000,
      });

      if (!data || data.length === 0) {
        throw new Error("Endere√ßo n√£o encontrado ou n√£o foi poss√≠vel geocodificar.");
      }

      console.log(`[GeocodeService] Coordenadas encontradas para: "${query}"`);
      return data;
    } catch (error) {
      if (axios.isAxiosError(error)) {
        console.error(`[GeocodeService] Erro na API do Nominatim: ${error.response?.status} ${error.message}`);
        throw new Error("Erro de comunica√ß√£o com o servi√ßo de geolocaliza√ß√£o.");
      }
      console.error("[GeocodeService] Erro ao buscar coordenadas:", error);
      throw error;
    }
  }
}
```

--- Caminho: backend/src/services/viacepService.ts ---
```typescript
import axios from "axios";
import db from "../database/database";
import { ViaCepResponse, CacheStatus } from "../types/viacep";

export class ViaCepService {
  private readonly cacheTTLHours = 24;

  /**
   * Normaliza o CEP removendo caracteres n√£o num√©ricos
   */
  private normalizeCep(cep: string): string {
    return cep.replace(/\D/g, "");
  }

  /**
   * M√©todo principal que busca CEP com cache no banco de dados
   */
  async buscarEnderecoPorCep(cep: string): Promise<ViaCepResponse> {
    const normalizedCep = this.normalizeCep(cep);
    
    if (normalizedCep.length !== 8) {
      throw new Error("CEP deve conter exatamente 8 d√≠gitos");
    }

    // 1. Tenta buscar do cache (banco de dados)
    const cachedData = await this.getCachedCep(normalizedCep);
    if (cachedData) {
      console.log(`‚úÖ [ViaCEP] Cache HIT para CEP: ${normalizedCep}`);
      return cachedData;
    }

    // 2. Se n√£o houver cache v√°lido, busca na API externa
    console.log(`‚ùå [ViaCEP] Cache MISS. Buscando na API externa...`);
    const apiData = await this.fetchFromViaCepAPI(normalizedCep);

    // 3. Salva no cache do banco de dados
    await this.saveCachedCep(normalizedCep, apiData);

    return apiData;
  }

  /**
   * Busca CEP no cache do banco de dados
   */
  private async getCachedCep(cep: string): Promise<ViaCepResponse | null> {
    try {
      const query = `
        SELECT 
          cep, logradouro, complemento, unidade, 
          bairro, localidade, uf
        FROM viacep_cache 
        WHERE cep = $1 AND expires_at > NOW()
        LIMIT 1
      `;

      const result = await db.query(query, [this.formatCepWithHyphen(cep)]);

      if (result.rows.length > 0) {
        return result.rows[0] as ViaCepResponse;
      }

      return null;
    } catch (error) {
      console.error("Erro ao buscar CEP no cache:", error);
      return null; // Em caso de erro, continua para API externa
    }
  }

  /**
   * Busca CEP na API externa do ViaCEP
   */
  private async fetchFromViaCepAPI(cep: string): Promise<ViaCepResponse> {
    const url = `https://viacep.com.br/ws/${cep}/json/`;
    console.log(`[ViaCEP] Buscando dados em: ${url}`);

    try {
      const { data } = await axios.get<ViaCepResponse>(url, {
        timeout: 10000,
        headers: {
          'User-Agent': 'LogoAli-App/1.0.0',
        },
      });

      // Verifica se a API retornou erro (CEP n√£o encontrado)
      if ('erro' in data) {
        throw new Error("CEP n√£o encontrado");
      }

      return data;
    } catch (error: any) {
      if (axios.isAxiosError(error)) {
        if (error.response?.status === 404) {
          throw new Error("CEP n√£o encontrado");
        }
        throw new Error("Falha na conex√£o com o servi√ßo de CEP");
      }
      throw new Error(error.message || "Erro ao buscar CEP");
    }
  }

  /**
   * Salva CEP no cache do banco de dados
   */
  private async saveCachedCep(cep: string, data: ViaCepResponse): Promise<void> {
    try {
      const expiresAt = new Date();
      expiresAt.setHours(expiresAt.getHours() + this.cacheTTLHours);

      const formattedCep = this.formatCepWithHyphen(cep);

      const query = `
        INSERT INTO viacep_cache (
          cep, logradouro, complemento, unidade, 
          bairro, localidade, uf, expires_at
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        ON CONFLICT (cep) 
        DO UPDATE SET
          logradouro = EXCLUDED.logradouro,
          complemento = EXCLUDED.complemento,
          unidade = EXCLUDED.unidade,
          bairro = EXCLUDED.bairro,
          localidade = EXCLUDED.localidade,
          uf = EXCLUDED.uf,
          cached_at = CURRENT_TIMESTAMP,
          expires_at = EXCLUDED.expires_at,
          updated_at = CURRENT_TIMESTAMP
      `;

      await db.query(query, [
        formattedCep,
        data.logradouro || '',
        data.complemento || '',
        data.unidade || '',
        data.bairro || '',
        data.localidade || '',
        data.uf || '',
        expiresAt,
      ]);

      console.log(`üíæ [ViaCEP] CEP ${formattedCep} salvo no cache at√© ${expiresAt.toLocaleString('pt-BR')}`);
    } catch (error) {
      console.error("Erro ao salvar CEP no cache:", error);
      // N√£o lan√ßa erro para n√£o impedir o retorno dos dados
    }
  }

  /**
   * Formata CEP com h√≠fen (12345678 -> 12345-678)
   */
  private formatCepWithHyphen(cep: string): string {
    const normalized = this.normalizeCep(cep);
    if (normalized.length === 8) {
      return `${normalized.substring(0, 5)}-${normalized.substring(5)}`;
    }
    return normalized;
  }

  /**
   * Obt√©m estat√≠sticas do cache
   */
  async getCacheStats() {
    try {
      const totalQuery = "SELECT COUNT(*) as total FROM viacep_cache";
      const validQuery = "SELECT COUNT(*) as valid FROM viacep_cache WHERE expires_at > NOW()";
      const expiredQuery = "SELECT COUNT(*) as expired FROM viacep_cache WHERE expires_at <= NOW()";

      const [totalResult, validResult, expiredResult] = await Promise.all([
        db.query(totalQuery),
        db.query(validQuery),
        db.query(expiredQuery),
      ]);

      return {
        total: parseInt(totalResult.rows[0].total),
        valid: parseInt(validResult.rows[0].valid),
        expired: parseInt(expiredResult.rows[0].expired),
        ttlHours: this.cacheTTLHours,
      };
    } catch (error) {
      console.error("Erro ao obter estat√≠sticas do cache:", error);
      return {
        total: 0,
        valid: 0,
        expired: 0,
        ttlHours: this.cacheTTLHours,
        error: "Falha ao obter estat√≠sticas",
      };
    }
  }

  /**
   * Remove entradas expiradas do cache
   */
  async clearExpiredCache() {
    try {
      const query = "DELETE FROM viacep_cache WHERE expires_at <= NOW()";
      const result = await db.query(query);
      
      return {
        removidos: result.rowCount || 0,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      console.error("Erro ao limpar cache expirado:", error);
      return {
        removidos: 0,
        error: "Falha ao limpar cache expirado",
        timestamp: new Date().toISOString(),
      };
    }
  }

  /**
   * M√©todo para testes - insere dados fake no cache
   */
  seedCache(cep: string, data: ViaCepResponse) {
    // Para manter compatibilidade com o controller existente
    // mas agora usa o banco de dados
    const normalized = this.normalizeCep(cep);
    return this.saveCachedCep(normalized, data).then(() => ({
      ok: true,
      cep: this.formatCepWithHyphen(normalized),
      message: "Dados inseridos no cache do banco de dados"
    }));
  }
}
```


--- Caminho: backend/src/types ---
--- Caminho: backend/src/types/cataBagulho.ts ---
```typescript
export interface CataBagulhoResult {
  street: string;
  startStretch?: string;
  endStretch?: string;
  dates: string[];
  frequency: string;
  shift: string;
  schedule: string;
}

export interface CataBagulhoCacheData {
  id: number;
  latitude: number;
  longitude: number;
  results: CataBagulhoResult[];
  cached_at: Date;
  expires_at: Date;
}
```

--- Caminho: backend/src/types/viacep.ts ---
```typescript
export interface ViaCepResponse {
  cep: string;
  logradouro: string;
  complemento: string;
  unidade: string;
  bairro: string;
  localidade: string;
  uf: string;
}

export interface ViaCepCacheData extends ViaCepResponse {
  id?: number;
  cached_at?: Date;
  expires_at?: Date;
  created_at?: Date;
  updated_at?: Date;
}

export interface CacheStatus {
  hit: boolean;
  expired: boolean;
  source: "cache" | "api";
}

export interface ViaCepApiResponse extends ViaCepResponse {
  cacheStatus: CacheStatus;
}

```




--- Caminho: estrutura_e_scripts_completa.txt ---

--- Caminho: frontend ---
--- Caminho: frontend/Dockerfile ---
```dockerfile
# frontend/Dockerfile (Configura√ß√£o para Desenvolvimento)
FROM node:20-alpine AS base

WORKDIR /app

# Copia package.json e instala depend√™ncias
# Usamos npm ci para instala√ß√µes limpas e consistentes
COPY package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./
RUN \
    if [ -f yarn.lock ]; then yarn install --frozen-lockfile; \
    elif [ -f package-lock.json ]; then npm ci; \
    elif [ -f pnpm-lock.yaml ]; then pnpm i --frozen-lockfile; \
    else npm ci; \
    fi

# Para desenvolvimento, n√£o precisamos de um est√°gio 'builder' separado para 'npm run build'
# O 'npm run dev' ser√° executado diretamente no container.
# Apenas copiamos o restante do c√≥digo fonte.
COPY . .

EXPOSE 3000

# O comando para iniciar o Next.js em modo de desenvolvimento
# Este comando ser√° sobrescrito pelo 'command' no docker-compose.yml
CMD ["npm", "run", "dev"]

```

--- Caminho: frontend/eslint.config.mjs ---

--- Caminho: frontend/next-env.d.ts ---
```typescript
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.

```

--- Caminho: frontend/next.config.ts ---
```typescript
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
  async rewrites() {
    return [
      {
        source: '/api/:path*',
        destination: 'http://logo-ali-back:3333/api/:path*',
      },
    ];
  },
  experimental: {
    turbo: {
      resolveExtensions: [
        '.mdx',
        '.tsx',
        '.ts',
        '.jsx',
        '.js',
        '.mjs',
        '.json',
      ],
    },
  },
};

export default nextConfig;
```

--- Caminho: frontend/package.json ---
```json
{
  "name": "logo-ali",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "lint:check": "prettier --check .",
    "lint:fix": "prettier --write ."
  },
  "dependencies": {
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "next": "15.4.5",
    "axios": "^1.11.0",
    "leaflet": "^1.9.4",
    "react-leaflet": "^5.0.0",
    "react-icons": "^5.5.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/leaflet": "^1.9.20",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.4.5",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}

```

--- Caminho: frontend/postcss.config.mjs ---

--- Caminho: frontend/public ---
--- Caminho: frontend/public/file.svg ---

--- Caminho: frontend/public/globe.svg ---

--- Caminho: frontend/public/icons ---

--- Caminho: frontend/public/next.svg ---

--- Caminho: frontend/public/vercel.svg ---

--- Caminho: frontend/public/window.svg ---


--- Caminho: frontend/src ---
--- Caminho: frontend/src/app ---
--- Caminho: frontend/src/app/favicon.ico ---

--- Caminho: frontend/src/app/globals.css ---

--- Caminho: frontend/src/app/layout.tsx ---

--- Caminho: frontend/src/app/page.tsx ---

--- Caminho: frontend/src/app/servicos ---
--- Caminho: frontend/src/app/servicos/loading.tsx ---

--- Caminho: frontend/src/app/servicos/page.tsx ---



--- Caminho: frontend/src/components ---
--- Caminho: frontend/src/components/layout ---
--- Caminho: frontend/src/components/layout/Footer.tsx ---

--- Caminho: frontend/src/components/layout/Header.tsx ---

--- Caminho: frontend/src/components/layout/Layout.tsx ---


--- Caminho: frontend/src/components/map ---
--- Caminho: frontend/src/components/map/MapView.tsx ---


--- Caminho: frontend/src/components/search ---
--- Caminho: frontend/src/components/search/SearchBar.tsx ---

--- Caminho: frontend/src/components/search/ServiceSelector.tsx ---


--- Caminho: frontend/src/components/services ---
--- Caminho: frontend/src/components/services/ServiceCard.tsx ---

--- Caminho: frontend/src/components/services/ServiceDatailsModal.tsx ---

--- Caminho: frontend/src/components/services/ServicesList.tsx ---


--- Caminho: frontend/src/components/ui ---
--- Caminho: frontend/src/components/ui/Button.tsx ---

--- Caminho: frontend/src/components/ui/Input.tsx ---

--- Caminho: frontend/src/components/ui/Loading.tsx ---



--- Caminho: frontend/src/context ---
--- Caminho: frontend/src/context/AppContext.tsx ---


--- Caminho: frontend/src/hooks ---
--- Caminho: frontend/src/hooks/useGeoLocation.ts ---
```typescript
import { useState, useEffect } from "react";
import type { Coordinates } from "../types/location";

interface GeoState {
  coords?: Coordinates | null;
  error?: string | null;
  loading: boolean;
}

export function useGeoLocation(enable = true) {
  const [state, setState] = useState<GeoState>({
    coords: undefined,
    error: null,
    loading: false,
  });

  useEffect(() => {
    if (
      !enable ||
      typeof navigator === "undefined" ||
      !("geolocation" in navigator)
    ) {
      setState((s) => ({
        ...s,
        error: "Geolocaliza√ß√£o n√£o dispon√≠vel",
        loading: false,
      }));
      return;
    }

    setState((s) => ({ ...s, loading: true }));

    const watcher = navigator.geolocation.getCurrentPosition(
      (pos) => {
        setState({
          coords: { lat: pos.coords.latitude, lng: pos.coords.longitude },
          error: null,
          loading: false,
        });
      },
      (err) => {
        setState({ coords: null, error: err.message, loading: false });
      },
      { enableHighAccuracy: true, timeout: 10000 }
    );

    return () => {
      // No watcher to clear for getCurrentPosition, kept for symmetry
    };
  }, [enable]);

  return state;
}

```

--- Caminho: frontend/src/hooks/useLocalStorage.ts ---
```typescript
import { useState, useEffect } from "react";

export function useLocalStorage<T>(key: string, initialValue: T) {
  const [state, setState] = useState<T>(() => {
    try {
      const raw =
        typeof window !== "undefined" ? localStorage.getItem(key) : null;
      return raw ? (JSON.parse(raw) as T) : initialValue;
    } catch {
      return initialValue;
    }
  });

  useEffect(() => {
    try {
      localStorage.setItem(key, JSON.stringify(state));
    } catch {
      // ignore
    }
  }, [key, state]);

  return [state, setState] as const;
}

```


--- Caminho: frontend/src/services ---
--- Caminho: frontend/src/services/api.ts ---
```typescript
import axios from "axios";
import { API_ENDPOINTS } from "../utils/constants";
import { CataBagulhoResult } from "../types/cataBagulho";

const instance = axios.create({
  baseURL: API_ENDPOINTS.BACKEND_BASE,
  timeout: 15000,
});

export async function searchCataBagulho(lat: number, lng: number): Promise<CataBagulhoResult[]> {
  try {
    const { data } = await instance.get('/cata-bagulho', {
      params: { lat, lng }
    });
    // A resposta do backend j√° vem com um objeto { data: [...] }, vamos retornar o array interno.
    return data.data || [];
  } catch (error) {
    if (axios.isAxiosError(error) && error.response) {
      throw new Error(error.response.data.error || "Erro ao buscar o servi√ßo Cata-Bagulho.");
    }
    throw new Error("Erro de conex√£o com o servidor para buscar o servi√ßo.");
  }
}
```

--- Caminho: frontend/src/services/nominatim.ts ---
```typescript
// --- Caminho: frontend/src/services/nominatim.ts ---
import axios from "axios";
import { API_ENDPOINTS } from "../utils/constants";
import { NominatimResult } from "../types/api";

const instance = axios.create({
  baseURL: API_ENDPOINTS.BACKEND_BASE,
  timeout: 15000,
});

export async function geocodeAddress(query: string): Promise<NominatimResult[]> {
  console.log(`[Frontend] Chamando backend para geocodificar: "${query}"`);
  try {
    // A requisi√ß√£o agora √© para o nosso backend, que far√° o proxy
    const { data } = await instance.get('/geocode', {
      params: { q: query }
    });

    if (data && data.success) {
        // A resposta do backend j√° vem com { success: true, data: [...] }
        return data.data || [];
    } else {
        throw new Error(data.message || "Erro retornado pelo backend de geocodifica√ß√£o.");
    }
  } catch (error) {
    if (axios.isAxiosError(error) && error.response) {
      console.error("Erro na geocodifica√ß√£o (resposta do backend):", error.response.data);
      throw new Error(error.response.data.message || "N√£o foi poss√≠vel converter o endere√ßo em coordenadas.");
    }
    console.error("Erro de conex√£o na geocodifica√ß√£o:", error);
    throw new Error("Erro de conex√£o com o servidor para obter coordenadas.");
  }
}
```

--- Caminho: frontend/src/services/viacep.ts ---
```typescript
import axios from "axios";
import { API_ENDPOINTS } from "../utils/constants";
import { ViaCepResponse } from "../types/location";

const BACKEND_API_URL = API_ENDPOINTS.BACKEND_BASE;

/**
 * Busca as informa√ß√µes de um CEP atrav√©s do nosso backend.
 * O backend gerencia o cache e a chamada para a API externa do ViaCEP.
 * @param cep O CEP a ser buscado (apenas d√≠gitos).
 * @returns Os dados do endere√ßo.
 */
export async function fetchCep(cep: string): Promise<ViaCepResponse> {
  const normalizedCep = cep.replace(/\D/g, "");

  if (normalizedCep.length !== 8) {
    throw new Error("CEP inv√°lido. Forne√ßa 8 d√≠gitos num√©ricos.");
  }

  try {
    // A requisi√ß√£o √© feita para a rota do nosso pr√≥prio backend
    const response = await axios.get(`${BACKEND_API_URL}/cep/${normalizedCep}`);
    
    // A resposta do backend j√° vem com a estrutura { success, data, meta }
    if (response.data && response.data.success) {
      return response.data.data;
    } else {
      throw new Error(response.data.message || "Ocorreu um erro no servidor.");
    }
  } catch (error) {
    if (axios.isAxiosError(error) && error.response) {
      // Repassa a mensagem de erro espec√≠fica do backend para o frontend
      throw new Error(error.response.data.message || "N√£o foi poss√≠vel buscar o CEP.");
    }
    // Erro gen√©rico de conex√£o
    throw new Error("Falha de conex√£o com o servidor.");
  }
}
```


--- Caminho: frontend/src/types ---
--- Caminho: frontend/src/types/api.ts ---
```typescript
export interface NominatimResult {
  place_id: number;
  licence?: string;
  osm_type?: string;
  osm_id?: number;
  boundingbox?: [string, string, string, string];
  lat: string;
  lon: string;
  display_name: string;
  class?: string;
  type?: string;
  importance?: number;
  icon?: string;
  address?: Record<string, any>;
}

export interface BackendServiceSearchResponse {
  services: Array<any>;
  total?: number;
  meta?: Record<string, any>;
}

```

--- Caminho: frontend/src/types/cataBagulho.ts ---
```typescript
export interface CataBagulhoResult {
  street: string;
  startStretch?: string;
  endStretch?: string;
  dates: string[];
  frequency: string;
  shift: string;
  schedule: string;
}
```

--- Caminho: frontend/src/types/location.ts ---
```typescript
export interface Coordinates {
  lat: number;
  lng: number;
}

export interface Address {
  street: string;
  number?: string;
  neighborhood?: string;
  city: string;
  state: string;
  cep: string;
  coordinates: Coordinates;
}

export interface ViaCepResponse {
  cep: string;
  logradouro: string;
  complemento: string;
  unidade: string;
  bairro: string;
  localidade: string;
  uf: string;
  // Adicionados para guardar as coordenadas ap√≥s geocodifica√ß√£o
  lat?: number;
  lon?: number;
}
```

--- Caminho: frontend/src/types/services.ts ---
```typescript
export interface Service {
  cepData: unknown;
  id: number;
  type: string;
  name: string;
  address: string;
  date: string;
  time: string;
  distance: string;
  description: string;
  coordinates: [number, number];
  additionalInfo?: Record<string, unknown>;
}

export interface ServiceSearchParams {
  cep: string;
  number: string;
  serviceType: string;
}

export interface CacheStatus {
  hit: boolean;
  expired: boolean;
  source: "cache" | "api";
}
```


--- Caminho: frontend/src/utils ---
--- Caminho: frontend/src/utils/constants.ts ---
```typescript
export const SAMPLE_STREETS = [
  "Rua Augusta",
  "Avenida Paulista",
  "Rua Oscar Freire",
  "Rua 25 de Mar√ßo",
  "Avenida Faria Lima",
  "Rua da Consola√ß√£o",
  "Largo do Arouche",
  "Rua Direita",
  "Avenida S√£o Jo√£o",
  "Rua Bar√£o de Itapetininga",
  "Rua do Carmo",
  "Pra√ßa da S√©",
  "Avenida Rebou√ßas",
  "Rua Haddock Lobo",
  "Rua Estados Unidos",
];

export const SERVICE_TYPES = [
  { value: "coleta-lixo", label: "Coleta de Lixo" },
  { value: "cata-bagulho", label: "Cata-Bagulho" },
  { value: "saude", label: "Sa√∫de P√∫blica" },
  { value: "vacinacao", label: "Vacina√ß√£o" },
  { value: "bem-estar-animal", label: "Bem-estar Animal" },
  { value: "zeladoria", label: "Zeladoria Urbana" },
  { value: "iluminacao", label: "Ilumina√ß√£o P√∫blica" },
  { value: "poda-arvores", label: "Poda de √Årvores" },
];

export const SERVICE_ICONS = {
  "coleta-lixo": "üóëÔ∏è",
  "cata-bagulho": "üöõ",
  saude: "üè•",
  vacinacao: "üíâ",
  "bem-estar-animal": "üêï",
  zeladoria: "üîß",
  iluminacao: "üí°",
  "poda-arvores": "üå≥",
};

// frontend/src/utils/constants.ts

const isServer = typeof window === "undefined";

// A URL do backend √© a √∫nica necess√°ria para as chamadas de API
export const API_ENDPOINTS = {
  BACKEND_BASE: "/api", // URL relativa para o navegador (proxy reverso do Next.js)
};

```

--- Caminho: frontend/src/utils/formatters.ts ---
```typescript
export function formatDistanceMetersToKm(distanceMeters?: number | string) {
  if (distanceMeters == null) return "‚Äî";
  const val =
    typeof distanceMeters === "string"
      ? Number(distanceMeters)
      : distanceMeters;
  if (isNaN(val)) return "‚Äî";
  if (val < 1000) return `${Math.round(val)} m`;
  return `${(val / 1000).toFixed(1)} km`;
}

export function formatDateISO(dateIso?: string) {
  if (!dateIso) return "‚Äî";
  try {
    const d = new Date(dateIso);
    return d.toLocaleDateString("pt-BR");
  } catch {
    return dateIso;
  }
}

export function formatTimeISO(dateIso?: string) {
  if (!dateIso) return "‚Äî";
  try {
    const d = new Date(dateIso);
    return d.toLocaleTimeString("pt-BR", {
      hour: "2-digit",
      minute: "2-digit",
    });
  } catch {
    return dateIso;
  }
}

export function formatCep(value: string) {
  const digits = value.replace(/\D/g, "");
  if (digits.length <= 5) return digits;
  return digits.substring(0, 5) + "-" + digits.substring(5, 8);
}

```

--- Caminho: frontend/src/utils/helpers.ts ---
```typescript
/**
 * Dist√¢ncia entre dois pontos em metros (Haversine)
 */
export function haversineDistance(
  lat1: number,
  lon1: number,
  lat2: number,
  lon2: number
) {
  const toRad = (v: number) => (v * Math.PI) / 180;
  const R = 6371000; // metros
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRad(lat1)) *
      Math.cos(toRad(lat2)) *
      Math.sin(dLon / 2) *
      Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

/**
 * Small helpers
 */
export function clamp(num: number, min = 0, max = 1) {
  return Math.max(min, Math.min(max, num));
}

export function isValidLatLng(lat?: number, lng?: number) {
  if (typeof lat !== "number" || typeof lng !== "number") return false;
  if (Number.isNaN(lat) || Number.isNaN(lng)) return false;
  if (lat < -90 || lat > 90) return false;
  if (lng < -180 || lng > 180) return false;
  return true;
}

```

--- Caminho: frontend/src/utils/validators.ts ---
```typescript
export function validateCep(cep: string): boolean {
  return /^\d{5}-\d{3}$/.test(cep);
}

export function formatCep(value: string): string {
  let formatted = value.replace(/\D/g, "");
  if (formatted.length > 5) {
    formatted = formatted.substring(0, 5) + "-" + formatted.substring(5, 8);
  }
  return formatted;
}

export function validateEmail(email: string): boolean {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

export function validatePhone(phone: string): boolean {
  const cleaned = phone.replace(/\D/g, "");
  return cleaned.length >= 10 && cleaned.length <= 11;
}

```



--- Caminho: frontend/tailwind.config.ts ---
```typescript

```


--- Caminho: gerar_estrutura.ts ---
```typescript
import * as fs from "fs";
import * as path from "path";

// Define o caminho raiz do projeto
// Use barras duplas para Windows para garantir que o path.join funcione corretamente
const rootPath: string = "C:\\workspace\\Meus Projetos\\LogoAli\\logo-ali";

// Define os tipos de arquivo cujo conte√∫do deve ser inclu√≠do
const contentFileTypes: string[] = [
  ".json",
  ".ts",
  ".js",
  ".sql",
  "Dockerfile",
  ".yml",
  ".env",
  ".md",
  ".prettierignore",
  ".gitignore",
  // Usamos path.join para garantir compatibilidade com o sistema de arquivos
  path.join(".vscode", "settings.json"),
];

// Define os padr√µes de exclus√£o (pastas e arquivos que n√£o devem ser inclu√≠dos)
const exclusionList = [
  "node_modules",
  "package-lock\\.json",
  "pnpm-lock\\.yaml",
  "yarn\\.lock",
  "\\.git",
  "\\.gitignore",
  "\\.gitattributes",
  "\\.vscode",
  "\\.prettierignore",
  "\\.prettierrc.*",
  "tsconfig\\.json",
  "jsconfig\\.json",
  "vite\\.config\\..*",
  "webpack\\.config\\..*",
  "\\.env.*",
  "\\.eslint.*",
  "\\.stylelint.*",
  "\\.bin",
  "@types",
  "node16",
  "\\.next",
  "dist",
  "build",
  "coverage",
  "test-results",
  "__tests__",
  "README\\.md",
  "gerar_estruturas",
  "estrutura_e_sctripts_completa",
];

const exclusions: RegExp = new RegExp(`(${exclusionList.join("|")})`);

// Define o nome do arquivo de sa√≠da
const outputFile: string = path.join(
  rootPath,
  "estrutura_e_scripts_completa.txt"
);

// Fun√ß√£o para obter a linguagem para o bloco de c√≥digo Markdown
function getLanguage(filename: string, relativePath: string): string {
  const ext: string = path.extname(filename);
  switch (ext) {
    case ".json":
      return "json";
    case ".ts":
      return "typescript";
    case ".js":
      return "javascript";
    case ".sql":
      return "sql";
    case ".yml":
      return "yaml";
    case ".md":
      return "markdown";
    default:
      if (filename === "Dockerfile") return "dockerfile";
      // Usa startsWith para cobrir .env, .env.development, etc.
      if (filename.startsWith(".env")) return "plaintext";
      if (filename === ".prettierignore" || filename === ".gitignore")
        return "plaintext";
      // Verifica o caminho relativo para settings.json para ser mais espec√≠fico
      if (
        relativePath ===
        path.join(".vscode", "settings.json").replace(/\\/g, "/")
      )
        return "json";
      return "plaintext";
  }
}

// Limpa o conte√∫do do arquivo de sa√≠da se ele j√° existir
// Garante codifica√ß√£o UTF-8 para evitar problemas de caracteres
fs.writeFileSync(
  outputFile,
  "Estrutura de pastas e arquivos com conte√∫do:\r\n",
  { encoding: "utf8" }
);

// Fun√ß√£o recursiva para percorrer diret√≥rios
function processDirectory(dirPath: string, depth: number): void {
  // Limita a profundidade para evitar loops infinitos ou excesso de arquivos
  if (depth > 4) {
    return;
  }

  let items: fs.Dirent[];
  try {
    items = fs.readdirSync(dirPath, { withFileTypes: true });
  } catch (error: any) {
    // Usamos 'any' para o tipo de erro para compatibilidade
    // Loga erro se n√£o conseguir ler o diret√≥rio (ex: permiss√£o negada)
    console.error(`Erro ao ler diret√≥rio '${dirPath}': ${error.message}`);
    return;
  }

  for (const item of items) {
    const fullPath: string = path.join(dirPath, item.name);
    // Normaliza o caminho para garantir que as barras sejam consistentes (Windows/Linux)
    const relativePath: string = fullPath
      .replace(rootPath, "")
      .replace(/^[\\\/]/, "")
      .replace(/\\/g, "/");

    // Testa exclus√µes usando o caminho relativo normalizado
    if (exclusions.test(relativePath)) {
      continue; // Ignora itens que correspondem aos padr√µes de exclus√£o
    }

    // Adiciona o caminho do arquivo/pasta ao arquivo de sa√≠da
    fs.appendFileSync(outputFile, `--- Caminho: ${relativePath} ---\r\n`, {
      encoding: "utf8",
    });

    if (item.isDirectory()) {
      processDirectory(fullPath, depth + 1); // Continua recursivamente para subdiret√≥rios
    } else {
      // Se for um arquivo, verifica se o conte√∫do deve ser inclu√≠do
      let includeContent: boolean = false;
      for (const type of contentFileTypes) {
        // Ajusta a l√≥gica de correspond√™ncia para ser mais robusta
        // Verifica se o caminho relativo termina com o tipo, ou se o nome do item √© o tipo
        // ou se o tipo cont√©m curingas e corresponde ao nome do item
        if (
          relativePath.endsWith(type) ||
          item.name === type ||
          (type.includes("*") &&
            item.name.match(new RegExp(type.replace(/\*/g, ".*"))))
        ) {
          includeContent = true;
          break;
        }
      }

      // Tratamento espec√≠fico para .vscode/settings.json, garantindo que seja inclu√≠do
      if (
        relativePath ===
        path.join(".vscode", "settings.json").replace(/\\/g, "/")
      ) {
        includeContent = true;
      }

      if (includeContent) {
        try {
          // L√™ o conte√∫do do arquivo
          let fileContent: string = fs.readFileSync(fullPath, {
            encoding: "utf8",
          });
          // Garante que fileContent √© uma string, mesmo que o arquivo esteja vazio
          if (typeof fileContent !== "string") {
            fileContent = String(fileContent);
          }
          const language: string = getLanguage(item.name, relativePath);
          fs.appendFileSync(outputFile, `\`\`\`${language}\r\n`, {
            encoding: "utf8",
          });
          fs.appendFileSync(outputFile, fileContent + "\r\n", {
            encoding: "utf8",
          });
          fs.appendFileSync(outputFile, "```\r\n", { encoding: "utf8" });
        } catch (error: any) {
          // Usamos 'any' para o tipo de erro para compatibilidade
          // Loga o erro no console e no arquivo de sa√≠da
          console.error(
            `Erro ao ler o conte√∫do do arquivo '${relativePath}': ${error.message}`
          );
          fs.appendFileSync(outputFile, `\`\`\`plaintext\r\n`, {
            encoding: "utf8",
          });
          fs.appendFileSync(
            outputFile,
            `Erro ao ler o conte√∫do do arquivo '${relativePath}': ${error.message}\r\n`,
            { encoding: "utf8" }
          );
          fs.appendFileSync(outputFile, "```\r\n", { encoding: "utf8" });
        }
      }
    }
    // Adiciona uma linha vazia para melhor separa√ß√£o visual entre os itens
    fs.appendFileSync(outputFile, "\r\n", { encoding: "utf8" });
  }
}

// Inicia o processo a partir da raiz
processDirectory(rootPath, 0);

console.log(`‚úÖ Estrutura e conte√∫do dos scripts salvos em ${outputFile}`);

```

--- Caminho: infra ---
--- Caminho: infra/docker-compose.yml ---
```yaml
services:
  logo-ali-front:
    build:
      context: ../frontend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    volumes:
      - ../frontend:/app
      - /app/node_modules
    environment:
      NODE_ENV: development
    command: npm run dev

  logo-ali-back:
    build:
      context: ../backend
      dockerfile: Dockerfile
    ports:
      - "3333:3333"
    volumes:
      - ../backend:/app
      - /app/node_modules
    environment:
      NODE_ENV: development
      POSTGRES_HOST: logo-ali-db
      POSTGRES_PORT: 5432
      POSTGRES_USER: admin
      POSTGRES_DB: logo_ali_db
      POSTGRES_PASSWORD: admin
      BACKEND_PORT: 3333
    depends_on:
      logo-ali-db:
        condition: service_healthy
    command: sh -c "dockerize -wait tcp://logo-ali-db:5432 -timeout 30s npm run dev"

  logo-ali-db:
    image: postgres:17.4-alpine3.21
    container_name: logo-ali-db
    environment:
      POSTGRES_USER: admin
      POSTGRES_DB: logo_ali_db
      POSTGRES_PASSWORD: admin
      POSTGRES_INITDB_ARGS: "--encoding=UTF-8 --lc-collate=C --lc-ctype=C"
    ports:
      - "5434:5432"
    volumes:
      - pgdata_logo-ali:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U admin -d logo_ali_db"]
      interval: 5s
      timeout: 5s
      retries: 5
    command:
      ["postgres", "-c", "log_statement=all", "-c", "log_destination=stderr"]

volumes:
  pgdata_logo-ali:

```


--- Caminho: package.json ---
```json
{
  "name": "logo-ali",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT",
  "scripts": {
    "lint:check": "prettier --check .",
    "lint:fix": "prettier --write .",
    "generate:structure": "npx ts-node gerar_estrutura.ts",
    "migrate:up": "npx ts-node src/database/migrations/migrate.ts up",
    "dev": "concurrently \"npm run dev --prefix frontend\" \"npm run dev --prefix backend\""
  },
  "devDependencies": {
    "@types/node": "^24.2.0",
    "@typescript-eslint/eslint-plugin": "^8.38.0",
    "@typescript-eslint/parser": "^8.38.0",
    "concurrently": "^9.2.0",
    "eslint": "^9.32.0",
    "eslint-config-prettier": "^10.1.8",
    "eslint-plugin-prettier": "^5.5.3",
    "prettier": "^3.6.2"
  },
  "dependencies": {
    "axios": "^1.11.0",
    "leaflet": "^1.9.4",
    "react-icons": "^5.5.0",
    "react-leaflet": "^5.0.0",
    "react-router-dom": "^7.8.0"
  }
}

```

