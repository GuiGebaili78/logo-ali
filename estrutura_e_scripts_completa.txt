Estrutura de pastas e arquivos com conte√∫do:
--- Caminho: backend ---
--- Caminho: backend/Dockerfile ---
```dockerfile
FROM node:20-alpine AS base

WORKDIR /app

COPY package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./

RUN \
    if [ -f yarn.lock ]; then yarn install --frozen-lockfile; \
    elif [ -f package-lock.json ]; then npm ci; \
    elif [ -f pnpm-lock.yaml ]; then pnpm i --frozen-lockfile; \
    else npm ci; \
    fi

FROM base AS builder

WORKDIR /app

COPY --from=base /app/node_modules ./node_modules
COPY tsconfig.json .
COPY src ./src

RUN npx tsc

FROM node:20-alpine AS runner

WORKDIR /app

# Instalar dockerize para aguardar o PostgreSQL
RUN apk add --no-cache wget
RUN wget https://github.com/jwilder/dockerize/releases/download/v0.6.1/dockerize-alpine-linux-amd64-v0.6.1.tar.gz \
    && tar -C /usr/local/bin -xzvf dockerize-alpine-linux-amd64-v0.6.1.tar.gz \
    && rm dockerize-alpine-linux-amd64-v0.6.1.tar.gz

COPY --from=builder /app/dist ./dist
COPY --from=base /app/node_modules ./node_modules
COPY package.json .

# Comando padr√£o aguarda o banco e inicia a aplica√ß√£o
CMD ["dockerize", "-wait", "tcp://logo-ali-db:5432", "-timeout", "30s", "node", "./dist/index.js"]
```

--- Caminho: backend/package.json ---
```json
{
  "name": "backend",
  "version": "1.0.0",
  "description": "API Backend para LogoAli - Servi√ßos P√∫blicos SP",
  "main": "dist/index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "npx tsc",
    "start": "node ./dist/index.js",
    "dev": "ts-node src/index.ts",
    "dev:watch": "nodemon --exec ts-node src/index.ts",
    "migrate:up": "npx ts-node src/database/migrations/migrate.ts up"
  },
  "keywords": [
    "viacep",
    "api",
    "cache",
    "sao-paulo",
    "servicos-publicos"
  ],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "dotenv": "^17.2.1",
    "express": "^5.1.0",
    "pg": "^8.16.3"
  },
  "devDependencies": {
    "@types/express": "^5.0.3",
    "@types/node": "^24.1.0",
    "@types/pg": "^8.15.5",
    "nodemon": "^3.1.10",
    "ts-node": "^10.9.2",
    "typescript": "^5.8.3"
  }
}

```

--- Caminho: backend/src ---
--- Caminho: backend/src/controllers ---
--- Caminho: backend/src/controllers/viacepController.ts ---
```typescript
import { Request, Response } from "express";
import { ViaCepService } from "../services/viacepService";
export class ViaCepController {
  private viaCepService: ViaCepService;

  constructor() {
    this.viaCepService = new ViaCepService();
  }

  /**
   * GET /api/cep/:cep
   * Busca informa√ß√µes de um CEP
   */
  public getCep = async (req: Request, res: Response): Promise<void> => {
    try {
      const { cep } = req.params;

      if (!cep) {
        res.status(400).json({
          error: "CEP √© obrigat√≥rio",
          message: "Informe um CEP v√°lido na URL",
        });
        return;
      }

      const startTime = Date.now();
      const result = await this.viaCepService.getCep(cep);
      const responseTime = Date.now() - startTime;

      res.status(200).json({
        success: true,
        data: {
          cep: result.cep,
          logradouro: result.logradouro,
          complemento: result.complemento,
          unidade: result.unidade,
          bairro: result.bairro,
          localidade: result.localidade,
          uf: result.uf,
        },
        meta: {
          cache: result.cacheStatus,
          responseTime: `${responseTime}ms`,
          timestamp: new Date().toISOString(),
        },
      });
    } catch (error: any) {
      console.error("Erro no controller ViaCEP:", error);

      res.status(400).json({
        success: false,
        error: "Erro ao buscar CEP",
        message: error.message,
        timestamp: new Date().toISOString(),
      });
    }
  };

  /**
   * GET /api/cep/cache/stats
   * Retorna estat√≠sticas do cache
   */
  public getCacheStats = async (req: Request, res: Response): Promise<void> => {
    try {
      const stats = await this.viaCepService.getCacheStats();

      res.status(200).json({
        success: true,
        data: {
          cache_stats: stats,
          cache_ttl_hours: 24,
          timestamp: new Date().toISOString(),
        },
      });
    } catch (error: any) {
      console.error("Erro ao obter estat√≠sticas do cache:", error);

      res.status(500).json({
        success: false,
        error: "Erro ao obter estat√≠sticas do cache",
        message: error.message,
        timestamp: new Date().toISOString(),
      });
    }
  };

  /**
   * DELETE /api/cep/cache/expired
   * Remove registros expirados do cache
   */
  public clearExpiredCache = async (
    req: Request,
    res: Response
  ): Promise<void> => {
    try {
      const deletedCount = await this.viaCepService.clearExpiredCache();

      res.status(200).json({
        success: true,
        message: `${deletedCount} registros expirados removidos do cache`,
        data: {
          deleted_records: deletedCount,
          timestamp: new Date().toISOString(),
        },
      });
    } catch (error: any) {
      console.error("Erro ao limpar cache:", error);

      res.status(500).json({
        success: false,
        error: "Erro ao limpar cache expirado",
        message: error.message,
        timestamp: new Date().toISOString(),
      });
    }
  };

  /**
   * POST /api/cep/test/fake
   * Endpoint para testar com dados fake (sem frontend)
   */
  public testWithFakeData = async (
    req: Request,
    res: Response
  ): Promise<void> => {
    try {
      const testCeps = [
        "01001-000", // Pra√ßa da S√©
        "04038-001", // Vila Ol√≠mpia
        "01310-100", // Av. Paulista
        "08540-226", // Ferraz de Vasconcelos
        "01234-567", // CEP fake para testar erro
      ];

      const results = [];

      for (const testCep of testCeps) {
        try {
          const startTime = Date.now();
          const result = await this.viaCepService.getCep(testCep);
          const responseTime = Date.now() - startTime;

          results.push({
            cep: testCep,
            success: true,
            data: result,
            responseTime: `${responseTime}ms`,
          });
        } catch (error: any) {
          results.push({
            cep: testCep,
            success: false,
            error: error.message,
          });
        }
      }

      res.status(200).json({
        success: true,
        message: "Teste com dados fake conclu√≠do",
        data: {
          total_tests: testCeps.length,
          results: results,
          timestamp: new Date().toISOString(),
        },
      });
    } catch (error: any) {
      console.error("Erro no teste fake:", error);

      res.status(500).json({
        success: false,
        error: "Erro ao executar teste fake",
        message: error.message,
        timestamp: new Date().toISOString(),
      });
    }
  };
}

```


--- Caminho: backend/src/database ---
--- Caminho: backend/src/database/database.ts ---
```typescript
import { Pool, QueryResult, QueryResultRow } from "pg";
import dotenv from "dotenv";
import path from "path";

// Carregar vari√°veis de ambiente
dotenv.config({
  path: path.resolve(__dirname, "..", "..", "..", ".env.development"),
});

// Determina a porta baseada no ambiente
function getDatabasePort(): number {
  const envPort = process.env.POSTGRES_PORT;

  // Se estamos dentro do Docker (NODE_ENV=development com Docker)
  // o PostgreSQL sempre roda na porta 5432 DENTRO da rede Docker
  if (
    process.env.NODE_ENV === "development" &&
    process.env.POSTGRES_HOST === "logo-ali-db"
  ) {
    console.log("üê≥ Executando dentro do Docker - usando porta interna 5432");
    return 5432;
  }

  // Se estamos rodando localmente (fora do Docker)
  // usa a porta do .env (5434 para este projeto)
  console.log(`üíª Executando localmente - usando porta ${envPort}`);
  return Number(envPort) || 5432;
}

const pool = new Pool({
  host: process.env.POSTGRES_HOST,
  port: getDatabasePort(),
  user: process.env.POSTGRES_USER,
  database: process.env.POSTGRES_DB,
  password: process.env.POSTGRES_PASSWORD,
  ssl: process.env.NODE_ENV === "production" ? true : false,
});

async function query(
  queryObject: string,
  params: any[] = []
): Promise<QueryResult<QueryResultRow>> {
  try {
    const result = await pool.query(queryObject, params);
    return result;
  } catch (error) {
    console.error(error);
    throw error;
  }
}

async function getClient() {
  return pool.connect();
}

export default {
  query,
  getClient,
};

```

--- Caminho: backend/src/database/migrations ---
--- Caminho: backend/src/database/migrations/001_initial_setup.sql ---
```sql
-- Migra√ß√£o inicial do sistema LogoAli
-- Arquivo: C:\workspace\Meus Projetos\LogoAli\logo-ali\backend\src\database\migrations\001_initial_setup.sql

-- Cria√ß√£o de extens√µes √∫teis (se necess√°rio)
-- CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Configura√ß√µes iniciais do banco
-- COMMENT ON DATABASE logo_ali_db IS 'Banco de dados do sistema LogoAli - Servi√ßos P√∫blicos SP';

-- Log da migra√ß√£o inicial
DO $$ 
BEGIN
    RAISE NOTICE 'Executando migra√ß√£o inicial 001_initial_setup.sql';
    RAISE NOTICE 'Sistema LogoAli - Base de dados inicializada';
END $$;
```

--- Caminho: backend/src/database/migrations/002_create_viacep_cache.sql ---
```sql
-- Migra√ß√£o para criar tabela de cache do ViaCEP
-- Arquivo: C:\workspace\Meus Projetos\LogoAli\logo-ali\backend\src\database\migrations\002_create_viacep_cache.sql

CREATE TABLE IF NOT EXISTS viacep_cache (
  id SERIAL PRIMARY KEY,
  cep VARCHAR(9) NOT NULL UNIQUE, -- formato: 01001-000
  logradouro VARCHAR(255),
  complemento VARCHAR(255),
  unidade VARCHAR(50),
  bairro VARCHAR(100),
  localidade VARCHAR(100),
  uf VARCHAR(2),
  cached_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- √çndices para otimizar consultas
CREATE INDEX IF NOT EXISTS idx_viacep_cache_cep ON viacep_cache(cep);
CREATE INDEX IF NOT EXISTS idx_viacep_cache_expires ON viacep_cache(expires_at);

-- Coment√°rios para documenta√ß√£o
COMMENT ON TABLE viacep_cache IS 'Cache para dados do ViaCEP com TTL de 24 horas';
COMMENT ON COLUMN viacep_cache.cep IS 'CEP no formato 00000-000';
COMMENT ON COLUMN viacep_cache.expires_at IS 'Data/hora de expira√ß√£o do cache';
COMMENT ON COLUMN viacep_cache.cached_at IS 'Quando foi armazenado no cache';
```

--- Caminho: backend/src/database/migrations/migrate.ts ---
```typescript
import fs from "fs";
import path from "path";
import db from "../database";

interface Migration {
  id: number;
  filename: string;
  content: string;
}

async function createMigrationsTable() {
  const query = `
    CREATE TABLE IF NOT EXISTS migrations (
      id SERIAL PRIMARY KEY,
      filename VARCHAR(255) NOT NULL UNIQUE,
      executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
  `;

  try {
    console.log("üîÑ Criando tabela de migra√ß√µes...");
    await db.query(query);
    console.log("‚úÖ Tabela 'migrations' criada/verificada com sucesso");
  } catch (error) {
    console.error("‚ùå Erro ao criar tabela de migra√ß√µes:", error);
    throw error;
  }
}

async function getExecutedMigrations(): Promise<string[]> {
  try {
    const result = await db.query(
      "SELECT filename FROM migrations ORDER BY id",
    );
    return result.rows.map((row: any) => row.filename);
  } catch (error) {
    // Se a tabela n√£o existir ainda
    if ((error as any).code === "42P01") {
      console.log("üìã Tabela de migra√ß√µes ainda n√£o existe");
      return [];
    }
    console.error("‚ùå Erro ao obter migra√ß√µes executadas:", error);
    throw error;
  }
}

async function getMigrationFiles(): Promise<Migration[]> {
  const migrationsDir = __dirname;

  if (!fs.existsSync(migrationsDir)) {
    console.log("üìÅ Criando diret√≥rio de migra√ß√µes...");
    fs.mkdirSync(migrationsDir, { recursive: true });
    return [];
  }

  const files = fs
    .readdirSync(migrationsDir)
    .filter((file) => file.endsWith(".sql"))
    .sort();

  console.log(`üìÑ Encontrados ${files.length} arquivos de migra√ß√£o:`, files);

  return files.map((filename) => {
    const content = fs.readFileSync(path.join(migrationsDir, filename), "utf8");
    const id = parseInt(filename.split("_")[0]) || 0;
    return { id, filename, content };
  });
}

async function executeMigration(migration: Migration) {
  const client = await db.getClient();

  try {
    console.log(`üîÑ Executando migra√ß√£o: ${migration.filename}`);

    // Inicia transa√ß√£o
    await client.query("BEGIN");

    // Executa o SQL da migra√ß√£o
    if (migration.content.trim()) {
      console.log(`üìù Executando SQL da migra√ß√£o...`);
      await client.query(migration.content);
    }

    // Registra a migra√ß√£o como executada
    await client.query("INSERT INTO migrations (filename) VALUES ($1)", [
      migration.filename,
    ]);

    // Confirma transa√ß√£o
    await client.query("COMMIT");

    console.log(`‚úÖ Migra√ß√£o executada com sucesso: ${migration.filename}`);
  } catch (error) {
    // Desfaz transa√ß√£o em caso de erro
    await client.query("ROLLBACK");
    console.error(`‚ùå Erro na migra√ß√£o ${migration.filename}:`, error);
    throw error;
  } finally {
    client.release();
  }
}

export async function runMigrations() {
  try {
    console.log("üöÄ Iniciando sistema de migra√ß√µes...");

    // Primeiro cria a tabela de migra√ß√µes
    await createMigrationsTable();

    // Busca migra√ß√µes j√° executadas
    const executedMigrations = await getExecutedMigrations();
    console.log(`üìã Migra√ß√µes j√° executadas: ${executedMigrations.length}`);

    // Busca arquivos de migra√ß√£o
    const migrationFiles = await getMigrationFiles();

    // Filtra migra√ß√µes pendentes
    const pendingMigrations = migrationFiles.filter(
      (migration) => !executedMigrations.includes(migration.filename),
    );

    if (pendingMigrations.length === 0) {
      console.log("‚úÖ Nenhuma migra√ß√£o pendente encontrada");
      return;
    }

    console.log(
      `‚öôÔ∏è Executando ${pendingMigrations.length} migra√ß√µes pendentes...`,
    );

    for (const migration of pendingMigrations) {
      await executeMigration(migration);
    }

    console.log("üéâ Todas as migra√ß√µes foram executadas com sucesso!");
  } catch (error) {
    console.error("üí• Erro durante execu√ß√£o das migra√ß√µes:", error);
    throw error;
  }
}

```



--- Caminho: backend/src/index.ts ---
```typescript
import express from "express";
import dotenv from "dotenv";
import path from "path";
import db from "./database/database";
import { runMigrations } from "./database/migrations/migrate";
import viaCepRoutes from "./routes/viacepRoutes";

// Carrega vari√°veis de ambiente
dotenv.config({
  path: path.resolve(__dirname, "..", "..", ".env.development"),
});

const app = express();
const PORT = process.env.BACKEND_PORT || 3333;

app.use(express.json());

async function startServer() {
  try {
    console.log("üîß === DEBUG INFO ===");
    console.log("NODE_ENV:", process.env.NODE_ENV);
    console.log("POSTGRES_HOST:", process.env.POSTGRES_HOST);
    console.log("POSTGRES_PORT:", process.env.POSTGRES_PORT);
    console.log("POSTGRES_DB:", process.env.POSTGRES_DB);
    console.log("POSTGRES_USER:", process.env.POSTGRES_USER);
    console.log(
      "POSTGRES_PASSWORD:",
      process.env.POSTGRES_PASSWORD ? "***SET***" : "NOT SET"
    );
    console.log("===================");

    console.log("üîÑ Aguardando 5 segundos para o PostgreSQL inicializar...");
    await new Promise((resolve) => setTimeout(resolve, 5000));

    console.log("üîÑ Testando conex√£o com banco de dados...");

    // Testa a conex√£o primeiro com mais detalhes
    try {
      const testResult = await db.query(
        "SELECT NOW() as current_time, version() as pg_version"
      );
      console.log("‚úÖ Conex√£o com banco estabelecida!");
      console.log("üìÖ Hora do servidor:", testResult.rows[0].current_time);
      console.log(
        "üêò Vers√£o PostgreSQL:",
        testResult.rows[0].pg_version.split(" ")[0]
      );
    } catch (connectionError) {
      console.error("‚ùå ERRO DE CONEX√ÉO:", connectionError);
      throw connectionError;
    }

    console.log("üîÑ Iniciando migra√ß√µes...");
    try {
      await runMigrations();
      console.log("‚úÖ Migra√ß√µes conclu√≠das!");
    } catch (migrationError) {
      console.error("‚ùå ERRO NAS MIGRA√á√ïES:", migrationError);
      throw migrationError;
    }

    // Verificar se as tabelas foram criadas
    try {
      const tableCheck = await db.query(`
        SELECT table_name
        FROM information_schema.tables
        WHERE table_schema = 'public'
      `);
      console.log(
        "üìã Tabelas existentes:",
        tableCheck.rows.map((r) => r.table_name)
      );
    } catch (error) {
      console.error("‚ùå Erro ao verificar tabelas:", error);
    }

    // ========== ROTAS ==========

    // Rota de status do sistema
    app.get("/api/status", async (req, res) => {
      try {
        const dbTest = await db.query("SELECT NOW() as time");
        const tablesResult = await db.query(`
          SELECT table_name
          FROM information_schema.tables
          WHERE table_schema = 'public'
        `);

        res.status(200).json({
          status: "Backend is running!",
          database: "Connected",
          port: PORT,
          server_time: dbTest.rows[0].time,
          tables: tablesResult.rows.map((r) => r.table_name),
          api_version: "1.0.0",
        });
      } catch (error: any) {
        console.error("Database connection failed:", error);
        res.status(500).json({
          status: "Backend is running!",
          database: "Disconnected",
          error: error.message,
        });
      }
    });

    // Rota para verificar migra√ß√µes
    app.get("/api/migrations", async (req, res) => {
      try {
        const result = await db.query("SELECT * FROM migrations ORDER BY id");
        res.status(200).json({
          migrations: result.rows,
          total: result.rowCount,
        });
      } catch (error: any) {
        res.status(500).json({
          error: "Erro ao buscar migra√ß√µes",
          message: error.message,
        });
      }
    });

    // Rota para for√ßar execu√ß√£o das migra√ß√µes
    app.post("/api/force-migrations", async (req, res) => {
      try {
        console.log("üîÑ For√ßando execu√ß√£o das migra√ß√µes...");
        await runMigrations();
        res.status(200).json({
          message: "Migra√ß√µes executadas com sucesso!",
        });
      } catch (error: any) {
        console.error("‚ùå Erro ao for√ßar migra√ß√µes:", error);
        res.status(500).json({
          error: "Erro ao executar migra√ß√µes",
          message: error.message,
        });
      }
    });

    // Registrar rotas do ViaCEP
    app.use("/api", viaCepRoutes);

    // CORRIGIDO: Middleware para rotas n√£o encontradas - removido o "*"
    app.use((req, res) => {
      res.status(404).json({
        error: "Rota n√£o encontrada",
        message: `Endpoint ${req.method} ${req.originalUrl} n√£o existe`,
        available_endpoints: [
          "GET /api/status",
          "GET /api/migrations",
          "POST /api/force-migrations",
          "GET /api/cep/:cep",
          "GET /api/cep/cache/stats",
          "DELETE /api/cep/cache/expired",
          "POST /api/cep/test/fake",
        ],
      });
    });

    app.listen(PORT, () => {
      console.log(`üöÄ Backend server listening on port ${PORT}`);
      console.log(`üìä Status: http://localhost:${PORT}/api/status`);
      console.log(`üìã Migra√ß√µes: http://localhost:${PORT}/api/migrations`);
      console.log(
        `üîÑ For√ßar migra√ß√µes: POST http://localhost:${PORT}/api/force-migrations`
      );
      console.log(`üìç ViaCEP: http://localhost:${PORT}/api/cep/{cep}`);
      console.log(
        `üìà Cache Stats: http://localhost:${PORT}/api/cep/cache/stats`
      );
      console.log(
        `üß™ Teste Fake: POST http://localhost:${PORT}/api/cep/test/fake`
      );
    });
  } catch (error) {
    console.error("üí• FALHA CR√çTICA ao iniciar o backend:");
    console.error("Erro completo:", error);
    console.error("Stack trace:", (error as Error).stack);
    process.exit(1);
  }
}

startServer();

```

--- Caminho: backend/src/routes ---
--- Caminho: backend/src/routes/viacepRoutes.ts ---
```typescript
import { Router } from "express";
import { ViaCepController } from "../controllers/viacepController";

const router = Router();
const viaCepController = new ViaCepController();

router.post("/cep/test/fake", viaCepController.testWithFakeData);

router.get("/cep/cache/stats", viaCepController.getCacheStats);
router.delete("/cep/cache/expired", viaCepController.clearExpiredCache);

router.get("/cep/:cep", viaCepController.getCep);

export default router;

```


--- Caminho: backend/src/services ---
--- Caminho: backend/src/services/viacepService.ts ---
```typescript
import db from "../database/database";
import {
  ViaCepResponse,
  ViaCepCacheData,
  ViaCepApiResponse,
  CacheStatus,
} from "../types/viacep";

export class ViaCepService {
  private readonly CACHE_TTL_HOURS = 24; // TTL de 24 horas
  private readonly VIACEP_BASE_URL = "https://viacep.com.br/ws";

  /**
   * Normaliza o CEP removendo caracteres especiais
   */
  private normalizeCep(cep: string): string {
    return cep.replace(/\D/g, "");
  }

  /**
   * Formata o CEP para o padr√£o 00000-000
   */
  private formatCep(cep: string): string {
    const normalized = this.normalizeCep(cep);
    if (normalized.length === 8) {
      return `${normalized.substring(0, 5)}-${normalized.substring(5)}`;
    }
    return normalized;
  }

  /**
   * Valida se o CEP tem formato v√°lido
   */
  private isValidCep(cep: string): boolean {
    const normalized = this.normalizeCep(cep);
    return /^\d{8}$/.test(normalized);
  }

  /**
   * Busca CEP no cache do banco de dados
   */
  private async getCachedCep(cep: string): Promise<ViaCepCacheData | null> {
    try {
      const formattedCep = this.formatCep(cep);

      const query = `
        SELECT * FROM viacep_cache 
        WHERE cep = $1 AND expires_at > NOW()
        ORDER BY cached_at DESC 
        LIMIT 1
      `;

      const result = await db.query(query, [formattedCep]);

      if (result.rows.length > 0) {
        console.log(`‚úÖ Cache HIT para CEP: ${formattedCep}`);
        return result.rows[0] as ViaCepCacheData;
      }

      console.log(`‚ùå Cache MISS para CEP: ${formattedCep}`);
      return null;
    } catch (error) {
      console.error("Erro ao buscar CEP no cache:", error);
      return null;
    }
  }

  /**
   * Salva CEP no cache
   */
  private async cacheCep(cepData: ViaCepResponse): Promise<void> {
    try {
      const expiresAt = new Date();
      expiresAt.setHours(expiresAt.getHours() + this.CACHE_TTL_HOURS);

      const query = `
        INSERT INTO viacep_cache (cep, logradouro, complemento, unidade, bairro, localidade, uf, expires_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        ON CONFLICT (cep) 
        DO UPDATE SET 
          logradouro = EXCLUDED.logradouro,
          complemento = EXCLUDED.complemento,
          unidade = EXCLUDED.unidade,
          bairro = EXCLUDED.bairro,
          localidade = EXCLUDED.localidade,
          uf = EXCLUDED.uf,
          expires_at = EXCLUDED.expires_at,
          cached_at = CURRENT_TIMESTAMP,
          updated_at = CURRENT_TIMESTAMP
      `;

      await db.query(query, [
        cepData.cep,
        cepData.logradouro,
        cepData.complemento,
        cepData.unidade,
        cepData.bairro,
        cepData.localidade,
        cepData.uf,
        expiresAt.toISOString(),
      ]);

      console.log(
        `üíæ CEP ${cepData.cep} salvo no cache at√© ${expiresAt.toISOString()}`
      );
    } catch (error) {
      console.error("Erro ao salvar CEP no cache:", error);
      throw error;
    }
  }

  /**
   * Busca CEP na API do ViaCEP
   */
  private async fetchFromViaCepApi(cep: string): Promise<ViaCepResponse> {
    try {
      const normalizedCep = this.normalizeCep(cep);
      const url = `${this.VIACEP_BASE_URL}/${normalizedCep}/json/`;

      console.log(`üåê Buscando CEP ${normalizedCep} na API ViaCEP...`);

      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`Erro HTTP: ${response.status}`);
      }

      const data = await response.json();

      if (data.erro) {
        throw new Error(`CEP ${normalizedCep} n√£o encontrado`);
      }

      // Retorna apenas os campos que queremos usar
      const result: ViaCepResponse = {
        cep: this.formatCep(data.cep),
        logradouro: data.logradouro || "",
        complemento: data.complemento || "",
        unidade: data.unidade || "",
        bairro: data.bairro || "",
        localidade: data.localidade || "",
        uf: data.uf || "",
      };

      console.log(`‚úÖ CEP ${result.cep} encontrado na API`);
      return result;
    } catch (error) {
      console.error(`Erro ao buscar CEP na API:`, error);
      throw error;
    }
  }

  /**
   * M√©todo principal para buscar CEP (com cache)
   */
  public async getCep(cep: string): Promise<ViaCepApiResponse> {
    // Valida√ß√£o do CEP
    if (!this.isValidCep(cep)) {
      throw new Error("CEP inv√°lido. Use o formato 00000000 ou 00000-000");
    }

    let cacheStatus: CacheStatus = {
      hit: false,
      expired: false,
      source: "api",
    };

    try {
      // 1. Tentar buscar no cache primeiro
      const cachedData = await this.getCachedCep(cep);

      if (cachedData) {
        cacheStatus = {
          hit: true,
          expired: false,
          source: "cache",
        };

        return {
          cep: cachedData.cep,
          logradouro: cachedData.logradouro || "",
          complemento: cachedData.complemento || "",
          unidade: cachedData.unidade || "",
          bairro: cachedData.bairro || "",
          localidade: cachedData.localidade || "",
          uf: cachedData.uf || "",
          cacheStatus,
        };
      }

      // 2. Se n√£o estiver no cache, buscar na API
      const apiData = await this.fetchFromViaCepApi(cep);

      // 3. Salvar no cache
      await this.cacheCep(apiData);

      cacheStatus = {
        hit: false,
        expired: false,
        source: "api",
      };

      return {
        ...apiData,
        cacheStatus,
      };
    } catch (error) {
      console.error("Erro no servi√ßo ViaCEP:", error);
      throw error;
    }
  }

  /**
   * Limpa cache expirado (m√©todo utilit√°rio)
   */
  public async clearExpiredCache(): Promise<number> {
    try {
      const query = "DELETE FROM viacep_cache WHERE expires_at <= NOW()";
      const result = await db.query(query, []);

      console.log(
        `üßπ Removidos ${result.rowCount || 0} registros expirados do cache`
      );
      return result.rowCount || 0;
    } catch (error) {
      console.error("Erro ao limpar cache expirado:", error);
      throw error;
    }
  }

  /**
   * Estat√≠sticas do cache
   */
  public async getCacheStats(): Promise<any> {
    try {
      const queries = [
        { sql: "SELECT COUNT(*) as total FROM viacep_cache", params: [] },
        {
          sql: "SELECT COUNT(*) as valid FROM viacep_cache WHERE expires_at > NOW()",
          params: [],
        },
        {
          sql: "SELECT COUNT(*) as expired FROM viacep_cache WHERE expires_at <= NOW()",
          params: [],
        },
      ];

      const [totalResult, validResult, expiredResult] = await Promise.all(
        queries.map(({ sql, params }) => db.query(sql, params))
      );

      return {
        total: parseInt(totalResult.rows[0].total),
        valid: parseInt(validResult.rows[0].valid),
        expired: parseInt(expiredResult.rows[0].expired),
      };
    } catch (error) {
      console.error("Erro ao obter estat√≠sticas do cache:", error);
      throw error;
    }
  }
}

```


--- Caminho: backend/src/types ---
--- Caminho: backend/src/types/viacep.ts ---
```typescript
export interface ViaCepResponse {
  cep: string;
  logradouro: string;
  complemento: string;
  unidade: string;
  bairro: string;
  localidade: string;
  uf: string;
}

export interface ViaCepCacheData extends ViaCepResponse {
  id?: number;
  cached_at?: Date;
  expires_at?: Date;
  created_at?: Date;
  updated_at?: Date;
}

export interface CacheStatus {
  hit: boolean;
  expired: boolean;
  source: "cache" | "api";
}

export interface ViaCepApiResponse extends ViaCepResponse {
  cacheStatus: CacheStatus;
}

```




--- Caminho: estrutura_e_scripts_completa.txt ---

--- Caminho: frontend ---
--- Caminho: frontend/Dockerfile ---
```dockerfile
# frontend/Dockerfile (Configura√ß√£o para Desenvolvimento)
FROM node:20-alpine AS base

WORKDIR /app

# Copia package.json e instala depend√™ncias
# Usamos npm ci para instala√ß√µes limpas e consistentes
COPY package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./
RUN \
    if [ -f yarn.lock ]; then yarn install --frozen-lockfile; \
    elif [ -f package-lock.json ]; then npm ci; \
    elif [ -f pnpm-lock.yaml ]; then pnpm i --frozen-lockfile; \
    else npm ci; \
    fi

# Para desenvolvimento, n√£o precisamos de um est√°gio 'builder' separado para 'npm run build'
# O 'npm run dev' ser√° executado diretamente no container.
# Apenas copiamos o restante do c√≥digo fonte.
COPY . .

EXPOSE 3000

# O comando para iniciar o Next.js em modo de desenvolvimento
# Este comando ser√° sobrescrito pelo 'command' no docker-compose.yml
CMD ["npm", "run", "dev"]

```

--- Caminho: frontend/eslint.config.mjs ---

--- Caminho: frontend/next-env.d.ts ---
```typescript
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.

```

--- Caminho: frontend/next.config.ts ---
```typescript
// frontend/next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: "standalone",
  // ... outras configura√ß√µes
};

module.exports = nextConfig;

```

--- Caminho: frontend/package.json ---
```json
{
  "name": "logo-ali",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "lint:check": "prettier --check .",
    "lint:fix": "prettier --write ."
  },
  "dependencies": {
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "next": "15.4.5"
  },
  "devDependencies": {
    "typescript": "^5",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@tailwindcss/postcss": "^4",
    "tailwindcss": "^4",
    "eslint": "^9",
    "eslint-config-next": "15.4.5",
    "@eslint/eslintrc": "^3"
  }
}

```

--- Caminho: frontend/postcss.config.mjs ---

--- Caminho: frontend/public ---
--- Caminho: frontend/public/file.svg ---

--- Caminho: frontend/public/globe.svg ---

--- Caminho: frontend/public/icons ---

--- Caminho: frontend/public/next.svg ---

--- Caminho: frontend/public/vercel.svg ---

--- Caminho: frontend/public/window.svg ---


--- Caminho: frontend/src ---
--- Caminho: frontend/src/app ---
--- Caminho: frontend/src/app/favicon.ico ---

--- Caminho: frontend/src/app/globals.css ---

--- Caminho: frontend/src/app/layout.tsx ---

--- Caminho: frontend/src/app/page.tsx ---


--- Caminho: frontend/src/components ---
--- Caminho: frontend/src/components/layout ---
--- Caminho: frontend/src/components/layout/Footer.tsx ---

--- Caminho: frontend/src/components/layout/Header.tsx ---

--- Caminho: frontend/src/components/layout/Layout.tsx ---


--- Caminho: frontend/src/components/map ---
--- Caminho: frontend/src/components/map/MapView.tsx ---


--- Caminho: frontend/src/components/search ---
--- Caminho: frontend/src/components/search/SearchBar.tsx ---

--- Caminho: frontend/src/components/search/ServiceSelector.tsx ---


--- Caminho: frontend/src/components/services ---
--- Caminho: frontend/src/components/services/ServiceCard.tsx ---

--- Caminho: frontend/src/components/services/ServiceDatailsModal.tsx ---

--- Caminho: frontend/src/components/services/ServicesList.tsx ---


--- Caminho: frontend/src/components/ui ---
--- Caminho: frontend/src/components/ui/Button.tsx ---

--- Caminho: frontend/src/components/ui/Input.tsx ---

--- Caminho: frontend/src/components/ui/Loading.tsx ---



--- Caminho: frontend/src/context ---
--- Caminho: frontend/src/context/AppContext.tsx ---


--- Caminho: frontend/src/hooks ---
--- Caminho: frontend/src/hooks/useGeoLocation.ts ---
```typescript
import { useState, useEffect } from "react";
import type { Coordinates } from "../types/location";

interface GeoState {
  coords?: Coordinates | null;
  error?: string | null;
  loading: boolean;
}

export function useGeoLocation(enable = true) {
  const [state, setState] = useState<GeoState>({
    coords: undefined,
    error: null,
    loading: false,
  });

  useEffect(() => {
    if (
      !enable ||
      typeof navigator === "undefined" ||
      !("geolocation" in navigator)
    ) {
      setState((s) => ({
        ...s,
        error: "Geolocaliza√ß√£o n√£o dispon√≠vel",
        loading: false,
      }));
      return;
    }

    setState((s) => ({ ...s, loading: true }));

    const watcher = navigator.geolocation.getCurrentPosition(
      (pos) => {
        setState({
          coords: { lat: pos.coords.latitude, lng: pos.coords.longitude },
          error: null,
          loading: false,
        });
      },
      (err) => {
        setState({ coords: null, error: err.message, loading: false });
      },
      { enableHighAccuracy: true, timeout: 10000 }
    );

    return () => {
      // No watcher to clear for getCurrentPosition, kept for symmetry
    };
  }, [enable]);

  return state;
}

```

--- Caminho: frontend/src/hooks/useLocalStorage.ts ---
```typescript
import { useState, useEffect } from "react";

export function useLocalStorage<T>(key: string, initialValue: T) {
  const [state, setState] = useState<T>(() => {
    try {
      const raw =
        typeof window !== "undefined" ? localStorage.getItem(key) : null;
      return raw ? (JSON.parse(raw) as T) : initialValue;
    } catch {
      return initialValue;
    }
  });

  useEffect(() => {
    try {
      localStorage.setItem(key, JSON.stringify(state));
    } catch {
      // ignore
    }
  }, [key, state]);

  return [state, setState] as const;
}

```

--- Caminho: frontend/src/hooks/useSearch.ts ---
```typescript
import { useState } from "react";
import type { ServiceSearchParams, Service } from "../types/services";
import * as api from "../services/api";

export function useSearch() {
  const [loading, setLoading] = useState(false);
  const [services, setServices] = useState<Service[]>([]);
  const [error, setError] = useState<string | null>(null);

  async function search(params: ServiceSearchParams) {
    setLoading(true);
    setError(null);
    try {
      const result = await api.searchServices(params);
      setServices(result.services ?? []);
      return result;
    } catch (err: any) {
      setError(err?.message ?? "Erro na busca");
      throw err;
    } finally {
      setLoading(false);
    }
  }

  return {
    loading,
    services,
    error,
    search,
    setServices,
  };
}

```


--- Caminho: frontend/src/services ---
--- Caminho: frontend/src/services/api.ts ---
```typescript
import axios from "axios";
import { API_ENDPOINTS } from "../utils/constants";
import type { ServiceSearchParams } from "../types/services";

const BACKEND = API_ENDPOINTS.BACKEND_BASE;

const instance = axios.create({
  baseURL: BACKEND,
  timeout: 15000,
});

export async function searchServices(params: ServiceSearchParams) {
  // Esperamos que o backend tenha um endpoint /services/search que aceite query params
  // Caso n√£o exista, este m√©todo pode ser adaptado para chamar endpoints individuais (viacep, nominatim, etc.)
  try {
    const resp = await instance.get("/services/search", { params });
    return resp.data;
  } catch (error) {
    // fallback: se backend n√£o existir, retornar mock ou lan√ßar
    throw error;
  }
}

export async function getServiceDetails(id: number) {
  try {
    const resp = await instance.get(`/services/${id}`);
    return resp.data;
  } catch (error) {
    throw error;
  }
}

```

--- Caminho: frontend/src/services/nominatim.ts ---
```typescript
import axios from "axios";
import { API_ENDPOINTS } from "../utils/constants";

export async function geocodeAddress(query: string) {
  // Usa Nominatim diretamente
  const url = API_ENDPOINTS.NOMINATIM;
  try {
    const resp = await axios.get(url, {
      params: {
        q: query,
        format: "json",
        addressdetails: 1,
        limit: 5,
      },
      headers: {
        "Accept-Language": "pt-BR",
        "User-Agent": "logo-ali-app/1.0 (contato: )",
      },
    });

    return resp.data; // array de resultados
  } catch (error) {
    throw error;
  }
}

```

--- Caminho: frontend/src/services/prefecture.ts ---
```typescript
import axios from "axios";
import { API_ENDPOINTS } from "../utils/constants";

/**
 * Fun√ß√µes pr√≥ximas √† prefeitura / APILIB
 * Observa√ß√£o: aqui fazemos chamadas para um endpoint backend hipot√©tico /prefecture/*
 * Caso seu backend implemente rotas espec√≠ficas, adapte os paths abaixo.
 */

const BACKEND = API_ENDPOINTS.BACKEND_BASE;
const client = axios.create({ baseURL: BACKEND, timeout: 15000 });

export async function fetchServicesFromPrefecture(
  lat: number,
  lng: number,
  serviceType?: string
) {
  try {
    const resp = await client.get("/prefecture/services", {
      params: { lat, lng, serviceType },
    });
    return resp.data;
  } catch (error) {
    // se backend n√£o tiver, repassar erro para tratamento
    throw error;
  }
}

```

--- Caminho: frontend/src/services/viacep.ts ---
```typescript
import axios from "axios";
import { API_ENDPOINTS } from "../utils/constants";

const VIACEP = API_ENDPOINTS.VIACEP;

/**
 * Tenta buscar pelo backend primeiro (caso tenha cache),
 * sen√£o busca direto no ViaCEP.
 */
export async function fetchCep(cep: string) {
  // normaliza
  const normalized = cep.replace(/\D/g, "");
  try {
    // tenta backend cache
    const backendUrl =
      process.env.NODE_ENV === "development"
        ? "http://localhost:3333/api"
        : "/api";
    const respBackend = await axios.get(`${backendUrl}/cep/${normalized}`);
    return respBackend.data;
  } catch {
    // fallback direto para ViaCEP
    const resp = await axios.get(`${VIACEP}/${normalized}/json/`);
    if (resp.data.erro) throw new Error("CEP n√£o encontrado");
    return resp.data;
  }
}

```


--- Caminho: frontend/src/types ---
--- Caminho: frontend/src/types/api.ts ---
```typescript
export interface NominatimResult {
  place_id: number;
  licence?: string;
  osm_type?: string;
  osm_id?: number;
  boundingbox?: [string, string, string, string];
  lat: string;
  lon: string;
  display_name: string;
  class?: string;
  type?: string;
  importance?: number;
  icon?: string;
  address?: Record<string, any>;
}

export interface BackendServiceSearchResponse {
  services: Array<any>;
  total?: number;
  meta?: Record<string, any>;
}

```

--- Caminho: frontend/src/types/location.ts ---
```typescript
export interface Coordinates {
  lat: number;
  lng: number;
}

export interface Address {
  street: string;
  number?: string;
  neighborhood?: string;
  city: string;
  state: string;
  cep: string;
  coordinates: Coordinates;
}

export interface ViaCepResponse {
  cep: string;
  logradouro: string;
  complemento: string;
  unidade: string;
  bairro: string;
  localidade: string;
  uf: string;
}

```

--- Caminho: frontend/src/types/services.ts ---
```typescript
export interface Service {
  id: number;
  type: string;
  name: string;
  address: string;
  date: string;
  time: string;
  distance: string;
  description: string;
  coordinates: [number, number];
  additionalInfo?: Record<string, any>;
}

export interface ServiceSearchParams {
  street?: string;
  streetNumber?: string;
  cep?: string;
  serviceType?: string;
}

export interface CacheStatus {
  hit: boolean;
  expired: boolean;
  source: "cache" | "api";
}

```


--- Caminho: frontend/src/utils ---
--- Caminho: frontend/src/utils/constants.ts ---
```typescript
export const SAMPLE_STREETS = [
  "Rua Augusta",
  "Avenida Paulista",
  "Rua Oscar Freire",
  "Rua 25 de Mar√ßo",
  "Avenida Faria Lima",
  "Rua da Consola√ß√£o",
  "Largo do Arouche",
  "Rua Direita",
  "Avenida S√£o Jo√£o",
  "Rua Bar√£o de Itapetininga",
  "Rua do Carmo",
  "Pra√ßa da S√©",
  "Avenida Rebou√ßas",
  "Rua Haddock Lobo",
  "Rua Estados Unidos",
];

export const SERVICE_TYPES = [
  { value: "coleta-lixo", label: "Coleta de Lixo" },
  { value: "cata-bagulho", label: "Cata-Bagulho" },
  { value: "saude", label: "Sa√∫de P√∫blica" },
  { value: "vacinacao", label: "Vacina√ß√£o" },
  { value: "bem-estar-animal", label: "Bem-estar Animal" },
  { value: "zeladoria", label: "Zeladoria Urbana" },
  { value: "iluminacao", label: "Ilumina√ß√£o P√∫blica" },
  { value: "poda-arvores", label: "Poda de √Årvores" },
];

export const SERVICE_ICONS = {
  "coleta-lixo": "üóëÔ∏è",
  "cata-bagulho": "üöõ",
  saude: "üè•",
  vacinacao: "üíâ",
  "bem-estar-animal": "üêï",
  zeladoria: "üîß",
  iluminacao: "üí°",
  "poda-arvores": "üå≥",
};

export const API_ENDPOINTS = {
  VIACEP: "https://viacep.com.br/ws",
  NOMINATIM: "https://nominatim.openstreetmap.org/search",
  BACKEND_BASE:
    process.env.NODE_ENV === "development"
      ? "http://localhost:3333/api"
      : "/api",
};

```

--- Caminho: frontend/src/utils/formatters.ts ---
```typescript
export function formatDistanceMetersToKm(distanceMeters?: number | string) {
  if (distanceMeters == null) return "‚Äî";
  const val =
    typeof distanceMeters === "string"
      ? Number(distanceMeters)
      : distanceMeters;
  if (isNaN(val)) return "‚Äî";
  if (val < 1000) return `${Math.round(val)} m`;
  return `${(val / 1000).toFixed(1)} km`;
}

export function formatDateISO(dateIso?: string) {
  if (!dateIso) return "‚Äî";
  try {
    const d = new Date(dateIso);
    return d.toLocaleDateString("pt-BR");
  } catch {
    return dateIso;
  }
}

export function formatTimeISO(dateIso?: string) {
  if (!dateIso) return "‚Äî";
  try {
    const d = new Date(dateIso);
    return d.toLocaleTimeString("pt-BR", {
      hour: "2-digit",
      minute: "2-digit",
    });
  } catch {
    return dateIso;
  }
}

export function formatCep(value: string) {
  const digits = value.replace(/\D/g, "");
  if (digits.length <= 5) return digits;
  return digits.substring(0, 5) + "-" + digits.substring(5, 8);
}

```

--- Caminho: frontend/src/utils/helpers.ts ---
```typescript
/**
 * Dist√¢ncia entre dois pontos em metros (Haversine)
 */
export function haversineDistance(
  lat1: number,
  lon1: number,
  lat2: number,
  lon2: number
) {
  const toRad = (v: number) => (v * Math.PI) / 180;
  const R = 6371000; // metros
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRad(lat1)) *
      Math.cos(toRad(lat2)) *
      Math.sin(dLon / 2) *
      Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

/**
 * Small helpers
 */
export function clamp(num: number, min = 0, max = 1) {
  return Math.max(min, Math.min(max, num));
}

export function isValidLatLng(lat?: number, lng?: number) {
  if (typeof lat !== "number" || typeof lng !== "number") return false;
  if (Number.isNaN(lat) || Number.isNaN(lng)) return false;
  if (lat < -90 || lat > 90) return false;
  if (lng < -180 || lng > 180) return false;
  return true;
}

```

--- Caminho: frontend/src/utils/validators.ts ---
```typescript
export function validateCep(cep: string): boolean {
  return /^\d{5}-\d{3}$/.test(cep);
}

export function formatCep(value: string): string {
  let formatted = value.replace(/\D/g, "");
  if (formatted.length > 5) {
    formatted = formatted.substring(0, 5) + "-" + formatted.substring(5, 8);
  }
  return formatted;
}

export function validateEmail(email: string): boolean {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

export function validatePhone(phone: string): boolean {
  const cleaned = phone.replace(/\D/g, "");
  return cleaned.length >= 10 && cleaned.length <= 11;
}

```



--- Caminho: frontend/tailwind.config.ts ---
```typescript

```


--- Caminho: gerar_estrutura.ts ---
```typescript
import * as fs from "fs";
import * as path from "path";

// Define o caminho raiz do projeto
// Use barras duplas para Windows para garantir que o path.join funcione corretamente
const rootPath: string = "C:\\workspace\\Meus Projetos\\LogoAli\\logo-ali";

// Define os tipos de arquivo cujo conte√∫do deve ser inclu√≠do
const contentFileTypes: string[] = [
  ".json",
  ".ts",
  ".js",
  ".sql",
  "Dockerfile",
  ".yml",
  ".env",
  ".md",
  ".prettierignore",
  ".gitignore",
  // Usamos path.join para garantir compatibilidade com o sistema de arquivos
  path.join(".vscode", "settings.json"),
];

// Define os padr√µes de exclus√£o (pastas e arquivos que n√£o devem ser inclu√≠dos)
const exclusionList = [
  "node_modules",
  "package-lock\\.json",
  "pnpm-lock\\.yaml",
  "yarn\\.lock",
  "\\.git",
  "\\.gitignore",
  "\\.gitattributes",
  "\\.vscode",
  "\\.prettierignore",
  "\\.prettierrc.*",
  "tsconfig\\.json",
  "jsconfig\\.json",
  "vite\\.config\\..*",
  "webpack\\.config\\..*",
  "\\.env.*",
  "\\.eslint.*",
  "\\.stylelint.*",
  "\\.bin",
  "@types",
  "node16",
  "\\.next",
  "dist",
  "build",
  "coverage",
  "test-results",
  "__tests__",
  "README\\.md",
  "gerar_estruturas",
  "estrutura_e_sctripts_completa",
];

const exclusions: RegExp = new RegExp(`(${exclusionList.join("|")})`);

// Define o nome do arquivo de sa√≠da
const outputFile: string = path.join(
  rootPath,
  "estrutura_e_scripts_completa.txt"
);

// Fun√ß√£o para obter a linguagem para o bloco de c√≥digo Markdown
function getLanguage(filename: string, relativePath: string): string {
  const ext: string = path.extname(filename);
  switch (ext) {
    case ".json":
      return "json";
    case ".ts":
      return "typescript";
    case ".js":
      return "javascript";
    case ".sql":
      return "sql";
    case ".yml":
      return "yaml";
    case ".md":
      return "markdown";
    default:
      if (filename === "Dockerfile") return "dockerfile";
      // Usa startsWith para cobrir .env, .env.development, etc.
      if (filename.startsWith(".env")) return "plaintext";
      if (filename === ".prettierignore" || filename === ".gitignore")
        return "plaintext";
      // Verifica o caminho relativo para settings.json para ser mais espec√≠fico
      if (
        relativePath ===
        path.join(".vscode", "settings.json").replace(/\\/g, "/")
      )
        return "json";
      return "plaintext";
  }
}

// Limpa o conte√∫do do arquivo de sa√≠da se ele j√° existir
// Garante codifica√ß√£o UTF-8 para evitar problemas de caracteres
fs.writeFileSync(
  outputFile,
  "Estrutura de pastas e arquivos com conte√∫do:\r\n",
  { encoding: "utf8" }
);

// Fun√ß√£o recursiva para percorrer diret√≥rios
function processDirectory(dirPath: string, depth: number): void {
  // Limita a profundidade para evitar loops infinitos ou excesso de arquivos
  if (depth > 4) {
    return;
  }

  let items: fs.Dirent[];
  try {
    items = fs.readdirSync(dirPath, { withFileTypes: true });
  } catch (error: any) {
    // Usamos 'any' para o tipo de erro para compatibilidade
    // Loga erro se n√£o conseguir ler o diret√≥rio (ex: permiss√£o negada)
    console.error(`Erro ao ler diret√≥rio '${dirPath}': ${error.message}`);
    return;
  }

  for (const item of items) {
    const fullPath: string = path.join(dirPath, item.name);
    // Normaliza o caminho para garantir que as barras sejam consistentes (Windows/Linux)
    const relativePath: string = fullPath
      .replace(rootPath, "")
      .replace(/^[\\\/]/, "")
      .replace(/\\/g, "/");

    // Testa exclus√µes usando o caminho relativo normalizado
    if (exclusions.test(relativePath)) {
      continue; // Ignora itens que correspondem aos padr√µes de exclus√£o
    }

    // Adiciona o caminho do arquivo/pasta ao arquivo de sa√≠da
    fs.appendFileSync(outputFile, `--- Caminho: ${relativePath} ---\r\n`, {
      encoding: "utf8",
    });

    if (item.isDirectory()) {
      processDirectory(fullPath, depth + 1); // Continua recursivamente para subdiret√≥rios
    } else {
      // Se for um arquivo, verifica se o conte√∫do deve ser inclu√≠do
      let includeContent: boolean = false;
      for (const type of contentFileTypes) {
        // Ajusta a l√≥gica de correspond√™ncia para ser mais robusta
        // Verifica se o caminho relativo termina com o tipo, ou se o nome do item √© o tipo
        // ou se o tipo cont√©m curingas e corresponde ao nome do item
        if (
          relativePath.endsWith(type) ||
          item.name === type ||
          (type.includes("*") &&
            item.name.match(new RegExp(type.replace(/\*/g, ".*"))))
        ) {
          includeContent = true;
          break;
        }
      }

      // Tratamento espec√≠fico para .vscode/settings.json, garantindo que seja inclu√≠do
      if (
        relativePath ===
        path.join(".vscode", "settings.json").replace(/\\/g, "/")
      ) {
        includeContent = true;
      }

      if (includeContent) {
        try {
          // L√™ o conte√∫do do arquivo
          let fileContent: string = fs.readFileSync(fullPath, {
            encoding: "utf8",
          });
          // Garante que fileContent √© uma string, mesmo que o arquivo esteja vazio
          if (typeof fileContent !== "string") {
            fileContent = String(fileContent);
          }
          const language: string = getLanguage(item.name, relativePath);
          fs.appendFileSync(outputFile, `\`\`\`${language}\r\n`, {
            encoding: "utf8",
          });
          fs.appendFileSync(outputFile, fileContent + "\r\n", {
            encoding: "utf8",
          });
          fs.appendFileSync(outputFile, "```\r\n", { encoding: "utf8" });
        } catch (error: any) {
          // Usamos 'any' para o tipo de erro para compatibilidade
          // Loga o erro no console e no arquivo de sa√≠da
          console.error(
            `Erro ao ler o conte√∫do do arquivo '${relativePath}': ${error.message}`
          );
          fs.appendFileSync(outputFile, `\`\`\`plaintext\r\n`, {
            encoding: "utf8",
          });
          fs.appendFileSync(
            outputFile,
            `Erro ao ler o conte√∫do do arquivo '${relativePath}': ${error.message}\r\n`,
            { encoding: "utf8" }
          );
          fs.appendFileSync(outputFile, "```\r\n", { encoding: "utf8" });
        }
      }
    }
    // Adiciona uma linha vazia para melhor separa√ß√£o visual entre os itens
    fs.appendFileSync(outputFile, "\r\n", { encoding: "utf8" });
  }
}

// Inicia o processo a partir da raiz
processDirectory(rootPath, 0);

console.log(`‚úÖ Estrutura e conte√∫do dos scripts salvos em ${outputFile}`);

```

--- Caminho: infra ---
--- Caminho: infra/docker-compose.yml ---
```yaml
services:
  logo-ali-front:
    build:
      context: ../frontend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    volumes:
      - ../frontend:/app
      - /app/node_modules
    environment:
      NODE_ENV: development
    command: npm run dev

  logo-ali-back:
    build:
      context: ../backend
      dockerfile: Dockerfile
    ports:
      - "3333:3333"
    volumes:
      - ../backend:/app
      - /app/node_modules
    environment:
      NODE_ENV: development
      POSTGRES_HOST: logo-ali-db
      POSTGRES_PORT: 5432
      POSTGRES_USER: admin
      POSTGRES_DB: logo_ali_db
      POSTGRES_PASSWORD: admin
      BACKEND_PORT: 3333
    depends_on:
      logo-ali-db:
        condition: service_healthy
    command: sh -c "dockerize -wait tcp://logo-ali-db:5432 -timeout 30s npm run dev"

  logo-ali-db:
    image: postgres:17.4-alpine3.21
    container_name: logo-ali-db
    environment:
      POSTGRES_USER: admin
      POSTGRES_DB: logo_ali_db
      POSTGRES_PASSWORD: admin
      POSTGRES_INITDB_ARGS: "--encoding=UTF-8 --lc-collate=C --lc-ctype=C"
    ports:
      - "5434:5432"
    volumes:
      - pgdata_logo-ali:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U admin -d logo_ali_db"]
      interval: 5s
      timeout: 5s
      retries: 5
    command:
      ["postgres", "-c", "log_statement=all", "-c", "log_destination=stderr"]

volumes:
  pgdata_logo-ali:

```


--- Caminho: package.json ---
```json
{
  "name": "logo-ali",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT",
  "scripts": {
    "lint:check": "prettier --check .",
    "lint:fix": "prettier --write .",
    "generate:structure": "npx ts-node gerar_estrutura.ts",
    "migrate:up": "npx ts-node src/database/migrations/migrate.ts up",
    "dev": "concurrently \"npm run dev --prefix frontend\" \"npm run dev --prefix backend\""
  },
  "devDependencies": {
    "@types/node": "^24.2.0",
    "@typescript-eslint/eslint-plugin": "^8.38.0",
    "@typescript-eslint/parser": "^8.38.0",
    "concurrently": "^9.2.0",
    "eslint": "^9.32.0",
    "eslint-config-prettier": "^10.1.8",
    "eslint-plugin-prettier": "^5.5.3",
    "prettier": "^3.6.2"
  },
  "dependencies": {
    "axios": "^1.11.0",
    "leaflet": "^1.9.4",
    "react-icons": "^5.5.0",
    "react-leaflet": "^5.0.0",
    "react-router-dom": "^7.8.0"
  }
}

```

